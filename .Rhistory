library(ggplot2)
library(ggiraph)
library(timetk)
# add the cluster number
dtw_cluster <- clus_group1 %>%
left_join(hclus_dtw, by=c("Description" = "type_col"))
# change date columns into rows
dtw_cluster_t <- dtw_cluster %>%
mutate_at(vars(contains("202")),as.numeric) %>%
gather(Date, value, 2:55)
# Add the word "Cluster"
dtw_cluster_t$cluster_group <- paste("Cluster", dtw_cluster_t$cluster_group)
# convert Date into date format
dtw_cluster_t$Date <- parse_date_time(dtw_cluster_t$Date, orders=c("%Y-%m-%d"))
# plot time series by cluster
ts <- plot_time_series(.data=dtw_cluster_t,
.date_var=Date,
.value=value,
.color_var=Description,
.facet_var=cluster_group,
.facet_ncol=2,
.facet_scales = "free_y",
.smooth=FALSE,
.line_size = 0.3,
.plotly_slider = TRUE,
.title = "Time Series Plot by cluster")
ts <- ts %>%
layout(hovermode="x",
hoverlabel=list(font=list(size=7)))
ts
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw, )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="Jaccard",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw, )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="jaccard",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw, )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw, )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw_basic",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, , )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="pr_DB",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, , )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="diagonal",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, , )
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="mean",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, dtw2, dtw_lb,, )
# parameter 4: method
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw_lb",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 4: method
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "p",
k=2,
distance="dtw_lb",
control = hierarchical_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Parameter 1: Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".)
# parameter 2: Number of cluster (k)
# parameter 3: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 4: method
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "p",
k=2,
distance="dtw_lb",
control = partitional_control(method = "complete"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
library(dtwclust)
library(tibble)
library(ggdendro)
# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: method
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw_lb",
control = hierarchical_control(method = "complete"),
centroid="x",
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(dtwclust)
library(tibble)
library(ggdendro)
# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: method
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw",
control = hierarchical_control(method = "complete"),
centroid="x",
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(dtwclust)
library(tibble)
library(ggdendro)
# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: hierarchical clustering method ("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median" or "centroid" .)
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw",
control = hierarchical_control(method = "ward.D"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
saveRDS(dwelling, file = "RDS/dwelling.rds")
library(readr)
T2.3 <- read_csv("data/T2-3.csv")
saveRDS(T2.3, file = "RDS/T2-3.rds")
#T2.6 <- read_csv("data/T2-6.csv")
#saveRDS(T2.6, file = "RDS/T2-6.rds")
T3.4 <- read_csv("data/T3-4.csv")
saveRDS(T3.4, file = "RDS/T3-4.rds")
T3.5 <- read_csv("data/T3-5.csv")
saveRDS(T3.5, file = "RDS/T3-5.rds")
T3.6 <- read_csv("data/T3-6.csv")
saveRDS(T3.6, file = "RDS/T3-6.rds")
T3.7 <- read_csv("data/T3-7.csv")
saveRDS(T3.7, file = "RDS/T3-7.rds")
T3.8 <- read_csv("data/T3-8.csv")
saveRDS(T3.8, file = "RDS/T3-8.rds")
T3.9 <- read_csv("data/T3-9.csv")
saveRDS(T3.9, file = "RDS/T3-9.rds")
# T5.1 <- read_csv("data/T5-1.csv")
# saveRDS(T5.1, file = "RDS/T5-1.rds")
#
# T5.2 <- read_csv("data/T5-2.csv")
# saveRDS(T5.2, file = "RDS/T5-2.rds")
#T5.3 <- read_csv("data/T5-3.csv")
#saveRDS(T5.3, file = "RDS/T5-3.rds")
# T5.4 <- read_csv("data/T5-4.csv")
# saveRDS(T5.4, file = "RDS/T5-4.rds")
#
# T5.5 <- read_csv("data/T5-5.csv")
# saveRDS(T5.4, file = "RDS/T5-5.rds")
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
dend_expend(clustering)[[3]]
#
# library(dendextend)
# clustering <- dist(as.numeric(normalize(clus_group1,-c(1))), method="euclidean")
# dend_expend(clustering)[[3]]
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
## Add clusters to dataframe
num_clus <- cutree(clust2, k=3)
clus_hc <- cbind(clus_group1, cluster = as.factor(num_clus))
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
library(dtwclust)
library(tibble)
library(ggdendro)
# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: hierarchical clustering method ("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median" or "centroid" .)
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw",
control = hierarchical_control(method = "ward.D"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(ggplot2)
library(ggiraph)
library(timetk)
# add the cluster number
dtw_cluster <- clus_group1 %>%
left_join(hclus_dtw, by=c("Description" = "type_col"))
# change date columns into rows
dtw_cluster_t <- dtw_cluster %>%
mutate_at(vars(contains("202")),as.numeric) %>%
gather(Date, value, 2:55)
# Add the word "Cluster"
dtw_cluster_t$cluster_group <- paste("Cluster", dtw_cluster_t$cluster_group)
# convert Date into date format
dtw_cluster_t$Date <- parse_date_time(dtw_cluster_t$Date, orders=c("%Y-%m-%d"))
# plot time series by cluster
ts <- plot_time_series(.data=dtw_cluster_t,
.date_var=Date,
.value=value,
.color_var=Description,
.facet_var=cluster_group,
.facet_ncol=2,
.facet_scales = "free_y",
.smooth=FALSE,
.line_size = 0.3,
.plotly_slider = TRUE,
.title = "Time Series Plot by cluster")
ts <- ts %>%
layout(hovermode="x",
hoverlabel=list(font=list(size=7)))
ts
# how to modify the tooltip? Town is being shown twice here...
View(dtw_cluster_t)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
library(tmap)
# change Description to upper case
dtw_cluster_t$Description <- toupper(dtw_cluster_t$Description)
# Preparing the choropleth map
mpsz_clus_dtw <- left_join(singapore, dtw_cluster_t, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus_dtw)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
dtw_cluster_t$Description <- toupper(dtw_cluster_t$Description)
# Preparing the choropleth map
mpsz_clus_dtw <- left_join(singapore, dtw_cluster_t, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus_dtw)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
dtw_cluster_t$Description <- toupper(dtw_cluster_t$Description)
# Preparing the choropleth map
mpsz_clus_dtw <- left_join(singapore, dtw_cluster_t, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus_dtw)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster_group", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
