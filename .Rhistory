hc <- hclust(clus_dist, method = "average")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="blue")
# hierarchical clustering using various methods - average
hc <- hclust(clus_dist, method = "average")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=5, border="blue")
# hierarchical clustering using various methods - average
hc <- hclust(clus_dist, method = "average")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, average method")
rect.hclust(hc, k=5, border="blue")
# hierarchical clustering using various methods - centroid
hc <- hclust(clus_dist, method = "centroid")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, centroid method")
rect.hclust(hc, k=5, border="blue")
# hierarchical clustering using various methods - centroid
hc <- hclust(clus_dist, method = "centroid")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, centroid method")
rect.hclust(hc, k=3, border="blue")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, main = "Divisive")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")
# k is for user to decide
rect.hclust(divisive.clust, k=5, border="blue")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# find optimal k - Silhouette method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=avg.silwidth)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Silhouette") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="blue")
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
install.packages("fpc")
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
"wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
stats.names[i] <- paste("Test", i-1)
for(j in seq_along(clust.assess)){
output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
}
for(d in 1:k) {
cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
cluster.sizes[d, i]
}
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
# find optimal k - Silhouette method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=avg.silwidth)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Silhouette") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# find k
num_k <- find_k(hc)
plot(num_k)
data.frame(t(cstats.table(clus_dist, hc, 15)))
# find optimal k - Silhouette method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within,cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Silhouette") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# find optimal k - Silhouette method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Silhouette") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# find optimal k - Silhouette method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# find optimal k - Silhouette
num_k <- find_k(hc)
plot(num_k)
dendro <- as.dendrogram(hc)
dendro
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 7, value =   c("darkslategray", "darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3", "gold3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 7")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 7, value =   c("darkslategray", "darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3", "cyan")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 7")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="darkslategray4")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("darkslategray", "darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3", "cyan")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 7")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("darkslategray4", "cyan", "darkslategray3", "gold3", "darkcyan", "cyan3",)) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("darkslategray4", "cyan", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("cyan","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
# find optimal k - Silhouette
num_k <- find_k(hc)
plot(num_k)
# hierarchical clustering using various methods - average
hc <- hclust(clus_dist, method = "average")
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, average method")
rect.hclust(hc, k=5, border="blue")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")
# k is for user to calibrate
rect.hclust(divisive.clust, k=5, border="blue")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")
# k is for user to calibrate
rect.hclust(divisive.clust, k=5, border="gold3")
# Find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, divisive.clust, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Divisive clustering") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Average silhouette width") +
theme(plot.title = element_text(hjust = 0.5))
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))
# Find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, divisive.clust, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Divisive clustering - elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))
## choose the number of k and add to dataframe
num_clus <- cutree(divisive.clust, k=6)
clus <- cbind(clus, as.factor(num_clus))
clus
View(clus)
View(clus)
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")
# k is for user to calibrate
rect.hclust(divisive.clust, k=6, border="gold3")
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
View(clus)
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
singapore
View(clus)
## choose the number of k and add to dataframe
num_clus <- cutree(divisive.clust, k=6)
clus <- cbind(clus, cluster = as.factor(num_clus))
View(clus)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
library(tmap)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
n = 6,
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
clus$cluster <- toupper(clus$cluster)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
n = 6,
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
clus$cluster <- toupper(clus$cluster)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
clus$cluster <- toupper(clus$cluster)
clus
# Preparing the choropleth map
# mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
# tmap_mode("view")
# tm_shape(mpsz_clus)+
#   tmap_options(check.and.fix = TRUE)+
#   tm_fill("cluster", id=paste("PLN_AREA_N"),
#           style = "pretty",
#           palette = "Greens") +
#   tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
clus$Description <- toupper(clus$Description)
clus
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Greens") +
tm_borders(alpha = 0.7)
library(tmap)
# change Description to upper case
clus$Description <- toupper(clus$Description)
clus
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
## choose the number of k and add to dataframe
num_clus <- cutree(divisive.clust, k=6)
clus_hc <- cbind(clus, cluster = as.factor(num_clus))
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
View(clus_hc)
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
## choose the number of k and add to dataframe
num_clus <- cutree(divisive.clust, k=6)
clus_hc <- cbind(clus, cluster = as.factor(num_clus))
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
library(factoextra)
#library(factoextra)
# scale
clus_kmeans <- scale(clus)
install.packages("NbClust")
# library(factoextra)
library(NbClust)
pamgower <- pam(clus_dist, diss = TRUE, k=5)
fviz_silhouette(pamgower)
install.packages("factoextra")
library(factoextra)
library(NbClust)
pamgower <- pam(clus_dist, diss = TRUE, k=5)
fviz_silhouette(pamgower)
install.packages("tidyr")
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
install.packages("vctrs")
install.packages("vctrs")
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
install.packages("vctrs")
install.packages("vctrs")
