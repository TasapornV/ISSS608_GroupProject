# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
## Read compressed data file
T2.3 <- readRDS(file = "RDS/T2-3.rds") # Peak System Demand
#T2.6 <- readRDS(file = "RDS/T2-6.rds") # Market Share of Electricity Generation
T3.4 <- readRDS(file = "RDS/T3-4.rds") # Total Household Electricity Consumption by Dwelling Type
T3.5 <- readRDS(file = "RDS/T3-5.rds") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type
#T3.6 <- readRDS(file = "RDS/T3-6.rds") # Market Share for Natural Gas Retail
#T3.7 <- readRDS(file = "RDS/T3-7.rds") # Natural Gas Consumption by Sub-Sector
#T3.8 <- readRDS(file = "RDS/T3-8.rds") # Total Household Town Gas Consumption by Dwelling Type
#T3.9 <- readRDS(file = "RDS/T3-9.rds") # Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type
#T5.1 <- readRDS(file = "RDS/T5-1.rds") # Electricity and Gas Tariffs
#T5.2 <- readRDS(file = "RDS/T5-2.rds") # Monthly Electricity Tariffs (Low Tension Tariffs)
#T5.3 <- readRDS(file = "RDS/T5-3.rds") # Annual Electricity Tariffs by Components (Low Tension Tariffs)
#T5.4 <- readRDS(file = "RDS/T5-4.rds") # Average Monthly Uniform Singapore Energy Prices (USEP)
#T5.5 <- readRDS(file = "RDS/T5-5.rds") # Monthly Town Gas Tariffs
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
## Add clusters to dataframe
num_clus <- cutree(clust2, k=3)
## Read compressed data file
T2.3 <- readRDS(file = "RDS/T2-3.rds") # Peak System Demand
#T2.6 <- readRDS(file = "RDS/T2-6.rds") # Market Share of Electricity Generation
T3.4 <- readRDS(file = "RDS/T3-4.rds") # Total Household Electricity Consumption by Dwelling Type
T3.5 <- readRDS(file = "RDS/T3-5.rds") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type
#T3.6 <- readRDS(file = "RDS/T3-6.rds") # Market Share for Natural Gas Retail
#T3.7 <- readRDS(file = "RDS/T3-7.rds") # Natural Gas Consumption by Sub-Sector
#T3.8 <- readRDS(file = "RDS/T3-8.rds") # Total Household Town Gas Consumption by Dwelling Type
#T3.9 <- readRDS(file = "RDS/T3-9.rds") # Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type
#T5.1 <- readRDS(file = "RDS/T5-1.rds") # Electricity and Gas Tariffs
#T5.2 <- readRDS(file = "RDS/T5-2.rds") # Monthly Electricity Tariffs (Low Tension Tariffs)
#T5.3 <- readRDS(file = "RDS/T5-3.rds") # Annual Electricity Tariffs by Components (Low Tension Tariffs)
#T5.4 <- readRDS(file = "RDS/T5-4.rds") # Average Monthly Uniform Singapore Energy Prices (USEP)
#T5.5 <- readRDS(file = "RDS/T5-5.rds") # Monthly Town Gas Tariffs
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
## Read compressed data file
T2.3 <- readRDS(file = "RDS/T2-3.rds") # Peak System Demand
#T2.6 <- readRDS(file = "RDS/T2-6.rds") # Market Share of Electricity Generation
T3.4 <- readRDS(file = "RDS/T3-4.rds") # Total Household Electricity Consumption by Dwelling Type
T3.5 <- readRDS(file = "RDS/T3-5.rds") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type
#T3.6 <- readRDS(file = "RDS/T3-6.rds") # Market Share for Natural Gas Retail
#T3.7 <- readRDS(file = "RDS/T3-7.rds") # Natural Gas Consumption by Sub-Sector
#T3.8 <- readRDS(file = "RDS/T3-8.rds") # Total Household Town Gas Consumption by Dwelling Type
#T3.9 <- readRDS(file = "RDS/T3-9.rds") # Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type
#T5.1 <- readRDS(file = "RDS/T5-1.rds") # Electricity and Gas Tariffs
#T5.2 <- readRDS(file = "RDS/T5-2.rds") # Monthly Electricity Tariffs (Low Tension Tariffs)
#T5.3 <- readRDS(file = "RDS/T5-3.rds") # Annual Electricity Tariffs by Components (Low Tension Tariffs)
#T5.4 <- readRDS(file = "RDS/T5-4.rds") # Average Monthly Uniform Singapore Energy Prices (USEP)
#T5.5 <- readRDS(file = "RDS/T5-5.rds") # Monthly Town Gas Tariffs
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
?dist
clustering <- dist(normalize(clus_group1,-c(1)),  method = "euclidean")
gc()
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
## Read compressed data file
T2.3 <- readRDS(file = "RDS/T2-3.rds") # Peak System Demand
#T2.6 <- readRDS(file = "RDS/T2-6.rds") # Market Share of Electricity Generation
T3.4 <- readRDS(file = "RDS/T3-4.rds") # Total Household Electricity Consumption by Dwelling Type
T3.5 <- readRDS(file = "RDS/T3-5.rds") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type
#T3.6 <- readRDS(file = "RDS/T3-6.rds") # Market Share for Natural Gas Retail
#T3.7 <- readRDS(file = "RDS/T3-7.rds") # Natural Gas Consumption by Sub-Sector
#T3.8 <- readRDS(file = "RDS/T3-8.rds") # Total Household Town Gas Consumption by Dwelling Type
#T3.9 <- readRDS(file = "RDS/T3-9.rds") # Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type
#T5.1 <- readRDS(file = "RDS/T5-1.rds") # Electricity and Gas Tariffs
#T5.2 <- readRDS(file = "RDS/T5-2.rds") # Monthly Electricity Tariffs (Low Tension Tariffs)
#T5.3 <- readRDS(file = "RDS/T5-3.rds") # Annual Electricity Tariffs by Components (Low Tension Tariffs)
#T5.4 <- readRDS(file = "RDS/T5-4.rds") # Average Monthly Uniform Singapore Energy Prices (USEP)
#T5.5 <- readRDS(file = "RDS/T5-5.rds") # Monthly Town Gas Tariffs
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(heatmaply)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)),  method = "euclidean")
shiny::runApp('Shiny_App_G9')
install.packages('rsconnect')
install.packages("rsconnect")
library(rsconnect)
rsconnect::deployApp('path/to/your/app')
library(rsconnect)
rsconnect::deployApp('E:\ISSS608_VisualAnalytics\ISSS608-GroupProject\Shiny_App_G9')
library(rsconnect)
rsconnect::deployApp('E:/ISSS608_VisualAnalytics/ISSS608-GroupProject/Shiny_App_G9')
library(rsconnect)
rsconnect::deployApp('E:/ISSS608_VisualAnalytics/ISSS608-GroupProject/Shiny_App_G9')
library(rsconnect)
rsconnect::deployApp('E:/ISSS608_VisualAnalytics/ISSS608-GroupProject/Shiny_App_G9')
rsconnect::setAccountInfo(name='tasatasa',
token='B75377B6D9C698DE9388CCB7C2498663',
secret='<SECRET>')
rsconnect::setAccountInfo(name='tasatasa',
token='B75377B6D9C698DE9388CCB7C2498663',
secret='kqnBYiK14a+Rjnahr00lxnMgAg2hyCu45eeTsbn0')
library(rsconnect)
rsconnect::deployApp('E:/ISSS608_VisualAnalytics/ISSS608-GroupProject/Shiny_App_G9')
library(rsconnect)
rsconnect::deployApp('E:/ISSS608_VisualAnalytics/ISSS608-GroupProject/Shiny_App_G9')
rsconnect::deployApp(account = "tasapornv")
shiny::runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
T3.5 <- readRDS(file = "RDS/T3-5.rds")
consumption <- T3.5
consumption <- consumption %>%
mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
mutate(year = as.character(year))
saveRDS(consumption, file = "RDS/anova.rds")
T3.5 <- readRDS(file = "RDS/T3-5.rds")
consumption <- T3.5
consumption <- consumption %>%
mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
mutate(year = as.character(year))
saveRDS(consumption, file = "RDS/anova.rds")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
View(consumption)
runApp('Shiny_App_G9')
install.packages("PMCMRplus")
install.packages("PMCMRplus")
shiny::runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
T3.5 <- read_csv("data/T3-5.csv")
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
library(lubridate)
T3.5 <- read_csv("data/T3-5.csv")
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
library(lubridate)
T3.5 <- read_csv("data/T3-5.csv")
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
saveRDS(clus_data, file = "RDS/clus_data.rds")
saveRDS(clus, file = "RDS/clus.rds")
# clus_data
# clus
runApp('Shiny_App_G9')
install.packages("PMCMRplus")
