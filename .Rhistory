#b <- b %>%
#  data.frame(energycost,a) %>%
#  select("year", "kwh_per_acc", "energy_costs_cent_per_kwh")
consumption %>%
group_by(year) %>%
# filter(year == "2022") %>%
ggplot(mapping = aes(x = year, y = kwh_per_acc)) +
# Make grouped boxplot
geom_boxplot(aes(fill = as.factor(Region)), color = "grey") +
theme_minimal() +
theme(legend.position = "top") +
scale_fill_viridis_d(option = "C") +
labs(title = "Average consumption per year by Region", y="kwh per acc", fill = "Region")
set.seed(1234)
consumption <- T3.5
consumption <- consumption %>%
mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
mutate(year = as.character(year))
ggbetweenstats(
data = consumption,
x = Region,
y = kwh_per_acc,
# type = "np",
messages = FALSE
)
consumption %>%
mutate(class = fct_reorder(Description, kwh_per_acc, .fun='mean')) %>%
ggplot( aes(x=reorder(Description, kwh_per_acc), y=kwh_per_acc)) +
geom_boxplot() +
stat_summary(fun.y=mean, geom="point", color="red") +
theme(legend.position="none") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
ggtitle("Boxplot of consumption per planning area")
summary(aov(kwh_per_acc ~ dwelling_type, data = consumption))
#library(shiny)
#library(shinydashboard)
#library(shinythemes)
#library(shinyWidgets)
library(RColorBrewer)
library(tidyverse)
library(lubridate)
library(geofacet)
library(treemap)
library(ggstatsplot)
library(ggridges)
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# clus_data
# clus
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
runApp('Shiny_App_G9')
library(ggplot2)
library(ggiraph)
library(timetk)
# add the cluster number
dtw_cluster <- clus_group1 %>%
left_join(hclus_dtw, by=c("Description" = "type_col"))
library(dtwclust)
library(tibble)
library(ggdendro)
# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: hierarchical clustering method ("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median" or "centroid" .)
cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
type = "h",
k=2,
distance="dtw",
control = hierarchical_control(method = "ward.D"),
preproc = NULL,
args=tsclust_args(dist = list(window.size = 5L)))
hclus_dtw <- cutree(cluster_dtw, k=4) %>%
as.data.frame(.) %>%
rename(.,cluster_group = .) %>%
rownames_to_column("type_col")
# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
library(ggplot2)
library(ggiraph)
library(timetk)
# add the cluster number
dtw_cluster <- clus_group1 %>%
left_join(hclus_dtw, by=c("Description" = "type_col"))
# change date columns into rows
dtw_cluster_t <- dtw_cluster %>%
mutate_at(vars(contains("202")),as.numeric) %>%
gather(Date, value, 2:55)
# Add the word "Cluster"
dtw_cluster_t$cluster_group <- paste("Cluster", dtw_cluster_t$cluster_group)
# convert Date into date format
dtw_cluster_t$Date <- parse_date_time(dtw_cluster_t$Date, orders=c("%Y-%m-%d"))
# plot time series by cluster
ts <- plot_time_series(.data=dtw_cluster_t,
.date_var=Date,
.value=value,
.color_var=Description,
.facet_var=cluster_group,
.facet_ncol=2,
.facet_scales = "free_y",
.smooth=FALSE,
.line_size = 0.3,
.plotly_slider = TRUE,
.title = "Time Series Plot by cluster")
ts <- ts %>%
layout(hovermode="x",
hoverlabel=list(font=list(size=7)))
ts
# how to modify the tooltip? Town is being shown twice here...
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
remotes::install_github("timelyportfolio/dataui")
library(dataui)
pacman::p_load(reactable, reactablefmtr, gt, gtExtras)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
# Click-and-appear
# When user click on 1 cluster, a table appear at the side or bottom listing all the towns in the same cluster.
dtw_cluster_t %>%
group_by(cluster_group, Description) %>%
summarise(sum(value)) %>%
filter(cluster_group==1)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# with normalization
library(heatmaply)
# making town the row names
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix[,-c(1,2)]),
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,60,NA),
scale_fill_gradient_fun = scale_fill_gradient2(
low = "red",
high = "green",
midpoint = 0.5,
limits = c(0, 1)),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering")
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#load lib
pacman::p_load(scales, viridis, hrbrthemes, lubridate, gridExtra, knitr, data.table, ggthemes, CGPfunctions, ggHoriPlot, gapminder, gganimate, ggbraid, ggstatsplot, ggiraph, plotly, performance, nortest, patchwork, ggdist, ggridges, tidyverse)
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
dwelling_bar <- dwelling %>%
select('date','DWELLING_TYPE','consumption_GWh')
dwelling_bar <- as.Date(dwelling_bar$date, format="%d-%m,-%Y")
pacman::p_load(reactable, reactablefmtr, gt, gtExtras)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#Display rate of change using Slopegraph
#User can choose any 2 years for comparison
startyear <- 2005
endyear <- 2021
cons_yr <- dwelling
cons_year <- cons_yr %>%
group_by(DWELLING_TYPE, year) %>%
summarise(mean_cons=round(mean(consumption_GWh),2))
p_slopegraph <- cons_year %>%
mutate(year = factor(year)) %>%
filter(year %in% c(startyear,endyear)) %>%
newggslopegraph(year, mean_cons, DWELLING_TYPE)
p_slopegraph1 <- p_slopegraph + labs(title = "Monthly Household Electricity Consumption between 2 years",
subtitle = "",
caption = "Source:ema.gov.sg")
p_slopegraph1
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
line_width = 1,
bandline = "innerquartiles",
bandline_color = "green"
)
)
)
)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
line_width = 1,
bandline = "innerquartiles",
bandline_color = "green"
)
)
)
)
#Allow users to switch between bandline and mean statline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
statline = "mean"
)
)
)
)
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
packages = c('dplyr','tidyquant','tidyverse','tsibble','feasts','forecast','fable'
,'tsibbletalk','tidymodels','earth'
,'stats','lubridate','data.table','ggplot2','plotly'
,'rmarkdown','knitr','devtools','tseries')
for (p in packages) {
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
arima %>%
ggplot(aes(x = Date, y = peak_system_demand_mw)) +
geom_line(size = 0.5)+
labs(title = "") +
theme(text = element_text(color = "#444444", family = 'Helvetica Neue')
,plot.title = element_text(size = 35, color = '#333333')
,axis.title = element_text(size = 14, color = '#333333')
,axis.title.y = element_text(angle = 0, vjust = .5)
) +
theme_tq() +
scale_color_tq()
arima_ts <- ts(data=arima$peak_system_demand_mw, start = c(2005,1), end = c(2022, 6), frequency=12)
plot.ts(arima_ts, plot.type=('single'))
arima_ds = diff(arima_ts, differences = 2)
ggplotly(plot(arima_ds))
arima_arima = auto.arima(arima_ts)
arima_arima
plot(forecast(arima_ts))
arima_tsbl  = as_tsibble(arima)
head(arima_tsbl)
arima_tsbl  = as_tsibble(arima)
full_arima = arima_tsbl %>%
fill_gaps() %>%
tidyr::fill(peak_system_demand_mw, .direction = "down")
head(full_arima)
full_arima_mth_agg = full_arima %>%
# index_by(Date = ~ Date(.)) %>%
summarise(
avg_demand = mean(peak_system_demand_mw, na.rm = TRUE)
)
head(full_arima_mth_agg)
full_arima %>%
gg_season(peak_system_demand_mw)+
labs(title = "",
subtitle = "",
y = "peak_system_demand_mw")
full_arima_2019 = full_arima %>%
filter(year == 2019) %>%
mutate(quarter= case_when(
mth >= 1 & mth <= 3 ~ 'Q1'
, mth >= 4 & mth <= 6 ~ 'Q2'
, mth >= 7 & mth <= 9 ~ 'Q3'
, mth >= 10 & mth <= 12 ~ 'Q4')) %>%
select(year, mth, peak_system_demand_mw, Date)
full_arima_2019 %>%
gg_lag(peak_system_demand_mw, geom = "point")+
labs(title = "Lag plot of the time plot of the humidity level of hourly meterological data",
y = "Humidity level")
full_arima_acf=full_arima_2019 %>% ACF(peak_system_demand_mw, lag_max = 36)
head(full_arima_acf)
full_arima_2019 %>%
ACF(peak_system_demand_mw) %>%
autoplot() + labs(title="")
full_arima_stl=full_arima %>%
summarise(peak_system_demand_mw = sum(peak_system_demand_mw)) %>%
model(STL(peak_system_demand_mw ~ season(window = 5))) %>%
components()
head(full_arima_stl)
full_arima_stl %>%
summarise(peak_system_demand_mw = sum(peak_system_demand_mw)) %>%
model(STL(peak_system_demand_mw ~ season(window = 5))) %>%
components() %>%
autoplot()+
labs(title = "",
y = "peak_system_demand_mw")
packages = c('dplyr','tidyquant','tidyverse','tsibble','feasts','forecast','fable'
,'tsibbletalk','tidymodels','earth'
,'stats','lubridate','data.table','ggplot2','plotly'
,'rmarkdown','knitr','devtools','tseries')
for (p in packages) {
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
arima %>%
ggplot(aes(x = Date, y = peak_system_demand_mw)) +
geom_line(size = 0.5)+
labs(title = "") +
theme(text = element_text(color = "#444444", family = 'Helvetica Neue')
,plot.title = element_text(size = 35, color = '#333333')
,axis.title = element_text(size = 14, color = '#333333')
,axis.title.y = element_text(angle = 0, vjust = .5)
) +
theme_tq() +
scale_color_tq()
arima_ts <- ts(data=arima$peak_system_demand_mw, start = c(2005,1), end = c(2022, 6), frequency=12)
plot.ts(arima_ts, plot.type=('single'))
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
# plot(forecast(arima_ts))
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
# plot(forecast(arima_ts))
arima_tsbl  = as_tsibble(arima)
full_arima = arima_tsbl %>%
# filter(year==2017) %>%
fill_gaps() %>%
tidyr::fill(peak_system_demand_mw, .direction = "down")
full_arima %>%
gg_tsdisplay(difference(peak_system_demand_mw), plot_type='partial')
runApp('Shiny_App_G9')
town <- subset(T3.5, Description != 'Overall' & Description !='Central Region' &
Description !='East Region' & Description !='North East Region' &
Description !='North Region' & Description !='West Region' &
kwh_per_acc != 's' & dwelling_type != 'Private Housing' &
dwelling_type != 'Public Housing' & month != 'Annual') %>%
mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd"))
#Adding housing type
town$type <- case_when(
town$dwelling_type %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
town$dwelling_type %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
View(town)
a <- town
a$Date <- yearmonth(as.yearmon(paste(a$year, a$mth), "%Y %m"))
View(a)
a$Date <- yearmonth(as.yearmon(paste(a$year, a$month), "%Y %m"))
a <- a %>%
group_by(Date) %>%
summarise(avgcon = mean(kwh_per_acc, na.rm = TRUE))
a %>%
gg_tsdisplay(difference(avgcon), plot_type='partial')
output$arima_plot <- renderPlot({
a %>%
gg_tsdisplay(difference(avgcon), plot_type='partial')
})
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
View(arima)
arima_ts
View(arima_arima)
