library(p,character.only = T)
}
library(readr)
#T2.3 <- read_csv("data/T2-3.csv")
#saveRDS(T2.3, file = "RDS/T2-3.rds")
#T2.6 <- read_csv("data/T2-6.csv")
#saveRDS(T2.6, file = "RDS/T2-6.rds")
T3.4 <- read_csv("data/T3-4.csv")
saveRDS(T3.4, file = "RDS/T3-4.rds")
T3.5 <- read_csv("data/T3-5.csv")
saveRDS(T3.5, file = "RDS/T3-5.rds")
T3.6 <- read_csv("data/T3-6.csv")
saveRDS(T3.6, file = "RDS/T3-6.rds")
T3.7 <- read_csv("data/T3-7.csv")
saveRDS(T3.7, file = "RDS/T3-7.rds")
T3.8 <- read_csv("data/T3-8.csv")
saveRDS(T3.8, file = "RDS/T3-8.rds")
T3.9 <- read_csv("data/T3-9.csv")
saveRDS(T3.9, file = "RDS/T3-9.rds")
# T5.1 <- read_csv("data/T5-1.csv")
# saveRDS(T5.1, file = "RDS/T5-1.rds")
#
# T5.2 <- read_csv("data/T5-2.csv")
# saveRDS(T5.2, file = "RDS/T5-2.rds")
#T5.3 <- read_csv("data/T5-3.csv")
#saveRDS(T5.3, file = "RDS/T5-3.rds")
# T5.4 <- read_csv("data/T5-4.csv")
# saveRDS(T5.4, file = "RDS/T5-4.rds")
#
# T5.5 <- read_csv("data/T5-5.csv")
# saveRDS(T5.4, file = "RDS/T5-5.rds")
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
# function to create table for clustering stats
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
"wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
stats.names[i] <- paste("Test", i-1)
for(j in seq_along(clust.assess)){
output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
}
for(d in 1:k) {
cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
cluster.sizes[d, i]
}
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
if(!require(p,character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
library(readr)
#T2.3 <- read_csv("data/T2-3.csv")
#saveRDS(T2.3, file = "RDS/T2-3.rds")
#T2.6 <- read_csv("data/T2-6.csv")
#saveRDS(T2.6, file = "RDS/T2-6.rds")
T3.4 <- read_csv("data/T3-4.csv")
saveRDS(T3.4, file = "RDS/T3-4.rds")
T3.5 <- read_csv("data/T3-5.csv")
saveRDS(T3.5, file = "RDS/T3-5.rds")
T3.6 <- read_csv("data/T3-6.csv")
saveRDS(T3.6, file = "RDS/T3-6.rds")
T3.7 <- read_csv("data/T3-7.csv")
saveRDS(T3.7, file = "RDS/T3-7.rds")
T3.8 <- read_csv("data/T3-8.csv")
saveRDS(T3.8, file = "RDS/T3-8.rds")
T3.9 <- read_csv("data/T3-9.csv")
saveRDS(T3.9, file = "RDS/T3-9.rds")
# T5.1 <- read_csv("data/T5-1.csv")
# saveRDS(T5.1, file = "RDS/T5-1.rds")
#
# T5.2 <- read_csv("data/T5-2.csv")
# saveRDS(T5.2, file = "RDS/T5-2.rds")
#T5.3 <- read_csv("data/T5-3.csv")
#saveRDS(T5.3, file = "RDS/T5-3.rds")
# T5.4 <- read_csv("data/T5-4.csv")
# saveRDS(T5.4, file = "RDS/T5-4.rds")
#
# T5.5 <- read_csv("data/T5-5.csv")
# saveRDS(T5.4, file = "RDS/T5-5.rds")
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 5, value =   rainbow(5)) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram")
# function to create table for clustering stats
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
"wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
stats.names[i] <- paste("Test", i-1)
for(j in seq_along(clust.assess)){
output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
}
for(d in 1:k) {
cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
cluster.sizes[d, i]
}
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))+
theme_dark()
# find optimal k - Silhouette
num_k <- find_k(hc)
plot(num_k)
fviz_silhouette(res.hc)
library(factoextra)
fviz_silhouette(res.hc)
library(factoextra)
fviz_silhouette(hc)
# hierarchical clustering using various methods - average
hc <- hclust(clus_dist, method = "average")
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, average method")
rect.hclust(hc, k=5, border="gold3")
# hierarchical clustering using various methods - centroid
hc <- hclust(clus_dist, method = "centroid")
# find k
num_k <- find_k(hc)
plot(num_k)
# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, centroid method")
rect.hclust(hc, k=3, border="blue")
divisive.clust <- diana(as.matrix(clus_dist),
diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")
# k is for user to calibrate
rect.hclust(divisive.clust, k=6, border="gold3")
# Find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, divisive.clust, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Divisive clustering - elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))
## choose the number of k and add to dataframe
num_clus <- cutree(divisive.clust, k=6)
clus_hc <- cbind(clus, cluster = as.factor(num_clus))
library(factoextra)
fviz_silhouette(clus)
library(factoextra)
fviz_silhouette(cstats.table(clus_dist, divisive.clust, 15))
clus_dist <- scale(clus_d)
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_d <- daisy(clus, metric="gower")
clus_dist <- scale(clus_d)
View(clus_dist)
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
View(clus_data)
View(clus)
clus_dist <- scale(clus_d[,3:50])
View(clus)
clus_dist <- scale(clus_d[,3:56])
clus_dist <- scale(clus_d[,1:56])
View(clus_dist)
clus_dist <- scale(clus_d)
View(clus_dist)
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
clus_scaled <- scale(clus_d[,3:56])
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
clus_scaled <- clus
clus_scaled[,3:56] <- scale(clus_d[,3:56])
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
fviz_dend(hc, rect = TRUE, show_labels = FALSE)
fviz_dend(hc, rect = TRUE, show_labels = "none")
fviz_dend(hc, rect = TRUE, show_labels = FALSE)
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
clus_matrix <- data.matrix(clus)
library(dendextend)
clus_matrix <- data.matrix(clus)
heatmap(clus_matrix)
View(clus_matrix)
library(dendextend)
row.names(clus) <- clus$Description
library(dendextend)
row.names(clus) <- c(clus$Description, clus$dwelling_type)
library(dendextend)
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix),
Colv=NA,
seriate = "none",
colors = Blues,
k_row = 5,
margins = c(NA,200,60,NA),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering"
)
library(dendextend)
library(heatmaply)
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix),
Colv=NA,
seriate = "none",
colors = Blues,
k_row = 5,
margins = c(NA,200,60,NA),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering"
)
library(dendextend)
library(heatmaply)
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix[,-c(1,2)]),
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
colors = Blues,
k_row = 5,
margins = c(NA,200,60,NA),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering"
)
# Clustering
library(cluster)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
library(dendextend)
library(heatmaply)
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix[,-c(1,2)]),
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
colors = Blues,
k_row = 3,
margins = c(NA,200,60,NA),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering"
)
clus_group <- clus %>%
groupby(Description) %>%
summarise_each(funs(sum))
clus_group <- clus %>%
group_by(Description) %>%
summarise_each(funs(sum))
clus_group <- clus %>%
group_by(Description) %>%
summarise_each(fun(sum))
clus_group <- clus %>%
group_by(Description) %>%
summarise_each(list(sum))
clus_group <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
clus_group
# row.names(clus) <- paste(clus$Description, clus$dwelling_type)
# clus_matrix <- data.matrix(clus)
# heatmaply(normalize(clus_matrix[,-c(1,2)]),
#           dist_method = "euclidean",
#           hclust_method = "average",
#           Colv=NA,
#           seriate = "none",
#           colors = Blues,
#           k_row = 3,
#           margins = c(NA,200,60,NA),
#           fontsize_row = 5,
#           fontsize_col = 5,
#           main="Hierarchical Clustering")
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
row.names(clus_group1) <- clus_group1$Description
clus_matrix1 <- data.matrix(clus_group1)
heatmaply(normalize(clus_matrix1[,-c(1,2)]),
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
colors = Blues,
k_row = 3,
margins = c(NA,200,60,NA),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering")
