)
#Plotting 1st & 3rd quartile vs median
stats_sysdemand %>%
ggplot(aes(x = date, y = `50%`)) +
# Ribbon
geom_ribbon(aes(ymin = `25%`, ymax = `75%`),
color = palette_light()[[1]], fill = palette_light()[[1]], alpha = 0.5) +
# Points
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
# Aesthetics
labs(title = "Average Monthly Peak System Demand by Quarter, Jan'05 to Jun'22",
x = "", y = "MW",
subtitle = "Range of 1st and 3rd quartile to show volatility") +
scale_color_tq(theme = "dark") +
theme_tq()
#Allow users to choose apply.quarterly or apply.yearly
# Custom function to return mean, sd, quantiles
custom_stat <- function(x, na.rm = TRUE, ...) {
# x     = numeric vector
# na.rm = boolean, whether or not to remove NA's
# ...   = additional args passed to quantile
c(mean    = mean(x, na.rm = na.rm),
stdev   = sd(x, na.rm = na.rm),
quantile(x, na.rm = na.rm, ...))
}
# Applying the custom function by quarter
probs = c(0.25, 0.5, 0.75)
stats_sysdemand <- sysdemand %>%
tq_transmute(
select     = peak_system_demand_mw,
mutate_fun = apply.quarterly,
FUN        = custom_stat,
na.rm      = TRUE,
probs = probs
)
#Plotting 1st & 3rd quartile vs median
stats_sysdemand %>%
ggplot(aes(x = date, y = `50%`)) +
# Ribbon
geom_ribbon(aes(ymin = `25%`, ymax = `75%`),
color = palette_light()[[1]], fill = palette_light()[[1]], alpha = 0.5) +
# Points
geom_point() +
geom_smooth(method = "loess", se = FALSE) +
# Aesthetics
labs(title = "Average Monthly Peak System Demand by Quarter, Jan'05 to Jun'22",
x = "", y = "MW",
subtitle = "Range of 1st and 3rd quartile to show volatility") +
scale_color_tq(theme = "dark") +
theme_tq()
#Plotting mean vs std dev
stats_sysdemand %>%
ggplot(aes(x = stdev, y = mean)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "Average Monthly Peak System Demand by Quarter, Jan'05 to Jun'22",
subtitle = "Mean vs Standard Deviation") +
scale_color_tq() +
theme_tq()
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b'%Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
p_line <- dwelling %>%
mutate(text = paste(monthyear,
"<br>Consumption (GWh):", consumption_GWh)) %>%
ggplot(aes(x = date, y = consumption_GWh, colour = DWELLING_TYPE)) +
#  facet_wrap(vars(class), ncol = 1) +
geom_line() +
geom_point() +
labs(title = "Monthly Household Electricity Consumption (GWh) by Dwelling Type, Jan'05 to Jun'22",
x = "", y = "GWh") +
theme_tq() +
#    scale_x_date(expand=c(0,0), date_breaks = "3 month", date_labels = "%b%y") +
theme(legend.position="bottom")
ggplotly(p_line, tooltip = "text")
#Comparison of Median Consumption by Dwelling Type per year
#Give user choice to choose the year
givenyear <- 2021
#plotting violin plot by dwelling type for private and public housing
private <- ggbetweenstats(data = dwelling |> filter(class == "Private", year == givenyear), x = DWELLING_TYPE, y = consumption_GWh,
xlab = "Dwelling Type", ylab = "GWh",
type = "np", pairwise.comparisons = T, pairwise.display = "ns",
mean.ci = T, p.adjust.method = "fdr",  conf.level = 0.95,
title = "Private",
package = "ggthemes", palette = "Tableau_10") +
theme(axis.title.x = element_blank())
#  + scale_y_continuous(limits = c(0, 1500000))
public <- ggbetweenstats(data = dwelling |> filter(class == "Public", year == givenyear), x = DWELLING_TYPE, y = consumption_GWh,
xlab = "Dwelling Type", ylab = "GWh",
type = "np", pairwise.comparisons = T, pairwise.display = "ns",
mean.ci = T, p.adjust.method = "fdr",  conf.level = 0.95,
title = "Public",
package = "ggthemes", palette = "Tableau_10") +
theme(axis.title.x = element_blank())
#  + scale_y_continuous(limits = c(0, 1500000))
#combining plots
combine_plots(
list(private, public),
plotgrid.args = list(nrow = 5),
annotation.args = list(
title = "Comparison of Monthly Household Electricity Consumption by Dwelling Type",
subtitle = paste0("Year",givenyear),
theme = theme(
plot.subtitle = element_text(size = 10),
plot.title = element_text(size = 12))))
runApp('Shiny_App_G9')
#load lib
library(CGPfunctions)
library(ggdist)
#Confidence Intervals of Median Household consumption
private_uncert <- ggplot(data = dwelling |> filter(year == givenyear),
aes(x = DWELLING_TYPE, y = consumption_GWh)) +
stat_pointinterval(point_interval = "median_qi",
.width = c(0.95,0.99),
point_color = "red3") +
labs(title = "Visualising Confidence Intervals of Median Electricity Consumption",
x = "", y = "GWh", subtitle = paste0("Year ", givenyear)) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
private_uncert
#Display rate of change using Slopegraph
#User can choose any 2 years for comparison
startyear <- 2005
endyear <- 2021
cons_yr <- dwelling
cons_year <- cons_yr %>%
group_by(DWELLING_TYPE, year) %>%
summarise(mean_cons=round(mean(consumption_GWh),2))
p_slopegraph <- cons_year %>%
mutate(year = factor(year)) %>%
filter(year %in% c(startyear,endyear)) %>%
newggslopegraph(year, mean_cons, DWELLING_TYPE)
p_slopegraph1 <- p_slopegraph + labs(title = "Monthly Household Electricity Consumption between 2 years",
subtitle = "",
caption = "Source:Singstat.gov.sg")
p_slopegraph1
runApp('Shiny_App_G9')
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
# Clustering
library(cluster)
library(dendextend)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
runApp('Shiny_App_G9')
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)
# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
output$dendro <- renderPlot({
hc <- hclust(clus_dist, method = "complete")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value = c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
})
output$dendro <- renderPlot({
hc <- hclust(clus_dist, method = "complete")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 6, value = c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
})
runApp('Shiny_App_G9')
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "complete")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
# function to create table for clustering stats
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
"wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
stats.names[i] <- paste("Test", i-1)
for(j in seq_along(clust.assess)){
output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
}
for(d in 1:k) {
cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
cluster.sizes[d, i]
}
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
layer = 'MP14_SUBZONE_WEB_PL',
crs = 3414)
singapore <- st_transform(mpsz, 4326)
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
runApp('Shiny_App_G9')
# function to create table for clustering stats
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
"wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
stats.names[i] <- paste("Test", i-1)
for(j in seq_along(clust.assess)){
output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
}
for(d in 1:k) {
cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
cluster.sizes[d, i]
}
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))
runApp('Shiny_App_G9')
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 10, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 3, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 3, value =   c("grey20","darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3")) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram")
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 3, value =   rainbow()) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
set("branches_k_color", k = 5, value =   rainbow(5)) %>%
set("branches_lwd", 0.6) %>%
set("labels_colors",
value = c("darkslategray")) %>%
set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
labs(x = "Num. observations", y = "Height", title = "Dendrogram")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))+
theme_dark()
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))+
theme_dark()
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5), theme_dark())
runApp('Shiny_App_G9')
runApp('Shiny_App_G9/example')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))+
theme_dark()
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))),
aes(x=cluster.number, y=within.cluster.ss)) +
geom_point()+
geom_line()+
ggtitle("Agglomerative (complete) - Elbow") +
labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
theme(plot.title = element_text(hjust = 0.5))+
theme_dark()
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)
# complete
hc <- hclust(clus_dist, method = "ward.D")
# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)
# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
tmap_options(check.and.fix = TRUE)+
tm_fill("cluster", id=paste("PLN_AREA_N"),
style = "pretty",
palette = "Blues") +
tm_borders(alpha = 0.7)
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
