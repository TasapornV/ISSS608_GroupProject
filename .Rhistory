arima_arima = auto.arima(arima_ts)
arima_arima
plot(forecast(arima_ts))
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
plot(forecast(arima_arima))
arima_tsbl  = as_tsibble(arima)
full_arima = arima_tsbl %>%
# filter(year==2017) %>%
fill_gaps() %>%
tidyr::fill(peak_system_demand_mw, .direction = "down")
full_arima %>%
gg_tsdisplay(difference(peak_system_demand_mw), plot_type='partial')
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
plot(forecast(arima))
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
plot(forecast(arima$peak_system_demand_mw))
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
plot(forecast(arima_ts))
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
# plot(forecast(arima_ts))
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima_ts <- ts(data=arima$peak_system_demand_mw)
arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)
# plot(forecast(arima_ts))
shiny::runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# Filter the required data for clustering
# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete
clus_data <- T3.5 %>%
filter(month != "Annual" &
year > 2017 &
dwelling_type != "Overall" &
!str_detect(Description,"Region|Pioneer|Overall"))
# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m"))
# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
arrange(date)
# pivot wider
clus <- clus_data %>%
pivot_wider(names_from=date, values_from=kwh_per_acc)
# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
dend_expend(clustering)[[3]]
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
shiny::runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
View(clus)
runApp('Shiny_App_G9')
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)
# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
group_by(Description) %>%
summarise_each(list(sum))
# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description
# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)
# plot
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = "euclidean",
hclust_method = "average",
Colv=NA,
seriate = "none",
k_row = 3,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 5,
fontsize_col = 5,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
dend_expend(clustering)[[3]]
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="manhattan")
dend_expend(clustering)[[3]]
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
# plot
observeEvent(c(input$k, input$method, input$method2, input$distance),{
output$dendro <- renderPlotly({
heatmaply(clus_matrix1[,-c(1)],
scale = "column",
dist_method = input$distance,
hclust_method = input$method2,
Colv=NA,
seriate = "none",
k_row = input$k,
margins = c(NA,200,50,NA),
colors = viridis(
n= 256, alpha=1,
begin=0, end=1,
option="viridis"),
fontsize_row = 7,
fontsize_col = 7,
main="Hierarchical Clustering",
ylab = "Towns",
xlab = "Time")
})
clustering <- dist(normalize(clus_group1,-c(1)), method=input$distance)
dend_expend(clustering)[[3]]
})
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
dend_expend(clustering)[[3]]
dend_expend(clustering)[[3]]
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="manhattan")
dend_expend(clustering)[[3]]
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="canberra")
dend_expend(clustering)[[3]]
# parameter: method
# user will need to input the distance calculated method here to determine which clustering method is optimal
library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="ward.D")
runApp('Shiny_App_G9')
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
plot(find_k(clust2))
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "ward.D2")
plot(find_k(clust2))
runApp('Shiny_App_G9')
runApp('Shiny_App_G9')
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
remotes::install_github("timelyportfolio/dataui")
library(dataui)
pacman::p_load(reactable, reactablefmtr, gt, gtExtras)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
dwelling_bar <- dwelling %>%
select('date','DWELLING_TYPE','consumption_GWh')
dwelling_bar <- as.Date(dwelling_bar$date, format="%d-%m,-%Y")
# Creating the rank and relative value
bar_data <- dwelling_bar %>%
group_by(date) %>%
mutate(rank = rank(-consumption_GWh),
Value_rel = ifelse(length(consumption_GWh) == 0, 0, consumption_GWh/consumption_GWh[rank==1]),
Value_lbl = paste0(" ", consumption_GWh)) %>%
ungroup()
#animated bar plot
anim <- ggplot(bar_data, aes(rank, group = DWELLING_TYPE,
fill = as.factor(DWELLING_TYPE), color = as.factor(DWELLING_TYPE))) +
geom_tile(aes(y = consumption_GWh,
height = consumption_GWh,
width = 0.9), alpha = 0.8, color = NA) +
geom_text(aes(y = consumption_GWh, label = paste(" ",DWELLING_TYPE,"\n",Value_lbl)), hjust = 0, color="black") +
coord_flip(clip = "off", expand = FALSE) +
scale_y_continuous(labels = scales::comma) +
scale_x_reverse() +
guides(color = FALSE, fill = FALSE) +
theme(axis.line=element_blank(),
axis.text.y=element_blank(),
axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
legend.position="none",
panel.background=element_blank(),
panel.border=element_blank(),
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.grid.major.x = element_line(linewidth=.1, color="grey80" ),
panel.grid.minor.x = element_line(linewidth=.1, color="grey80" ),
plot.title=element_text(size=20, hjust=0.5, face="bold", colour="black"),
plot.subtitle=element_text(size=18, hjust=0.5, face="italic", color="grey"),
plot.caption =element_text(size=8, hjust=0.5, face="italic", color="grey"),
plot.background=element_blank(),
plot.margin = margin(2,2, 2, 2, "cm"))
#load lib
pacman::p_load(scales, viridis, hrbrthemes, lubridate, gridExtra, knitr, data.table, ggthemes, CGPfunctions, ggHoriPlot, gapminder, gganimate, ggbraid, ggstatsplot, ggiraph, plotly, performance, nortest, patchwork, ggdist, ggridges, tidyverse)
# Creating the rank and relative value
bar_data <- dwelling_bar %>%
group_by(date) %>%
mutate(rank = rank(-consumption_GWh),
Value_rel = ifelse(length(consumption_GWh) == 0, 0, consumption_GWh/consumption_GWh[rank==1]),
Value_lbl = paste0(" ", consumption_GWh)) %>%
ungroup()
dwelling <- T3.4 %>%
filter(year %in% c(2005:2022)) %>%
filter(month %in% c(1:12)) %>%
filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive',
'Private Apartments and Condominiums',
'Landed Properties', 'Others')) %>%
mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
mutate(monthyear = format(as.Date(date), "%b %Y"))
#Add Private vs Public Classification
dwelling$class <- case_when(
dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
'Landed Properties', 'Others') ~ "Private",
dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
'5-room and Executive') ~ "Public")
dwelling_bar <- dwelling %>%
select('date','DWELLING_TYPE','consumption_GWh')
dwelling_bar <- as.Date(dwelling_bar$date, format="%d-%m,-%Y")
# Creating the rank and relative value
bar_data <- dwelling_bar %>%
group_by(date) %>%
mutate(rank = rank(-consumption_GWh),
Value_rel = ifelse(length(consumption_GWh) == 0, 0, consumption_GWh/consumption_GWh[rank==1]),
Value_lbl = paste0(" ", consumption_GWh)) %>%
ungroup()
#animated bar plot
anim <- ggplot(bar_data, aes(rank, group = DWELLING_TYPE,
fill = as.factor(DWELLING_TYPE), color = as.factor(DWELLING_TYPE))) +
geom_tile(aes(y = consumption_GWh,
height = consumption_GWh,
width = 0.9), alpha = 0.8, color = NA) +
geom_text(aes(y = consumption_GWh, label = paste(" ",DWELLING_TYPE,"\n",Value_lbl)), hjust = 0, color="black") +
coord_flip(clip = "off", expand = FALSE) +
scale_y_continuous(labels = scales::comma) +
scale_x_reverse() +
guides(color = FALSE, fill = FALSE) +
theme(axis.line=element_blank(),
axis.text.y=element_blank(),
axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
legend.position="none",
panel.background=element_blank(),
panel.border=element_blank(),
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
panel.grid.major.x = element_line(linewidth=.1, color="grey80" ),
panel.grid.minor.x = element_line(linewidth=.1, color="grey80" ),
plot.title=element_text(size=20, hjust=0.5, face="bold", colour="black"),
plot.subtitle=element_text(size=18, hjust=0.5, face="italic", color="grey"),
plot.caption =element_text(size=8, hjust=0.5, face="italic", color="grey"),
plot.background=element_blank(),
plot.margin = margin(2,2, 2, 2, "cm"))
#linechart # backup
ggplot(data = dwelling, aes(x = date)) +
geom_line(aes(y = consumption_GWh, colour = DWELLING_TYPE)) +
labs(title = "Electricity Consumption by Dwelling Type",
x = "Year", y = "Consumption (GWh)") +
scale_color_discrete(name="") +
theme(legend.position="bottom")
# cycleplot for each dwelling type
select_type <- 'Private Apartments and Condominiums'
select_dwelling <- dwelling %>%
filter(DWELLING_TYPE %in% c(select_type)) %>%
mutate(year = factor(year, levels = 2005:2022),
month = factor(month, levels = 1:12))
#Computing year average by months
hline.data <- select_dwelling %>%
group_by(month) %>%
summarise(avg_cons = mean(consumption_GWh))
#Plotting cycle plot for imports
ggplot() +
geom_line(data = select_dwelling,
aes(x=year,y=consumption_GWh, group=month), colour = "black") +
geom_hline(data = hline.data,
aes(yintercept=avg_cons),
linetype=6,
colour="red",
linewidth=0.5) +
facet_grid(~month) +
theme(axis.text.x = element_text(angle=90, vjust=1, hjust=1)) +
labs(title = "Cycleplot for household electricity consumption (GWh), Jan 2005-Jun 2022",
subtitle = paste0('Dwelling Type: ',select_type)) +
scale_x_discrete(breaks=c("2005","2010","2015","2020")) +
xlab("") +
ylab("GWh")
#Display rate of change using Slopegraph
#User can choose any 2 years for comparison
startyear <- 2005
endyear <- 2021
cons_yr <- dwelling
cons_year <- cons_yr %>%
group_by(DWELLING_TYPE, year) %>%
summarise(mean_cons=round(mean(consumption_GWh),2))
p_slopegraph <- cons_year %>%
mutate(year = factor(year)) %>%
filter(year %in% c(startyear,endyear)) %>%
newggslopegraph(year, mean_cons, DWELLING_TYPE)
p_slopegraph1 <- p_slopegraph + labs(title = "Monthly Household Electricity Consumption between 2 years",
subtitle = "",
caption = "Source:ema.gov.sg")
p_slopegraph1
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
line_width = 1,
bandline = "innerquartiles",
bandline_color = "green"
)
)
)
)
install.packages("dataui")
remotes::install_github("timelyportfolio/dataui")
library(dataui)
pacman::p_load(reactable, reactablefmtr, gt, gtExtras)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
line_width = 1,
bandline = "innerquartiles",
bandline_color = "green"
)
)
)
)
#data formatting
d_sparks <- dwelling %>%
filter(year %in% c(startyear:endyear)) %>%
mutate(`Dwelling Type` = DWELLING_TYPE) %>%
group_by(`Dwelling Type`) %>%
summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
line_width = 1,
bandline = "innerquartiles",
bandline_color = "green"
)
)
)
)
#Allow users to switch between bandline and mean statline
reactable(
d_sparks,
defaultPageSize = 13,
columns = list(
`Dwelling Type` = colDef(maxWidth = 200),
`Monthly Consumption` = colDef(
cell = react_sparkline(
d_sparks,
highlight_points = highlight_points(
min = "red", max = "blue"),
statline = "mean"
)
)
)
)
