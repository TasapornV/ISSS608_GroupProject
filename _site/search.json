[
  {
    "objectID": "Proposal.html",
    "href": "Proposal.html",
    "title": "Project Snapshot",
    "section": "",
    "text": "Singapore has progressively moved towards an open electricity market since 2001 to ensure a reliable energy supply and promote effective competition in the energy market.\nWith growing competition in the market, it becomes increasingly important for market players such as regulators, suppliers and retailers to understand the electricity consumption pattern in Singapore to ensure adequate supply planning and pricing structure.\nTo assist relevant market players in analyzing electricity consumption data effectively, we created this RShiny App to visualize Singapore electricity consumption pattern and trend, perform statistical analysis as well as forecast the future trends."
  },
  {
    "objectID": "Proposal.html#scope",
    "href": "Proposal.html#scope",
    "title": "Project Snapshot",
    "section": "Scope",
    "text": "Scope\nOur RShiny app allows users to interact with the data to:\n\nExplore the electricity consumption patterns and trends in Singapore,\nCluster planning areas based on similarities in consumption patterns,\nPerform inferential statistical analysis, and\nForecast future consumption trend.\n\nA detailed description and sketch of the proposed analyses and visualizations are presented in section 4 of this proposal."
  },
  {
    "objectID": "Proposal.html#data",
    "href": "Proposal.html#data",
    "title": "Project Snapshot",
    "section": "Data",
    "text": "Data\nThe data used in this project is extracted from Energy Market Authority (EMA) Singapore. It contains data between year 2005 and 2022, with a total of 35 tabs. The tabs are broadly categorized into 7 sections, namely:\n\nEnergy Supply\nEnergy Transformation\nEnergy Consumption\nEnergy Balances\nEnergy Prices\nSolar\nManpower\n\nFor this project, we will be focusing on household electricity consumption."
  },
  {
    "objectID": "Proposal.html#visualization-and-analysis",
    "href": "Proposal.html#visualization-and-analysis",
    "title": "Project Snapshot",
    "section": "Visualization and Analysis",
    "text": "Visualization and Analysis\n\nOverview Dashboard\nTo provide users some basic insights on the Singapore electricity consumption, an Overview tab is built for users to explore the electricity consumption by regions, planning areas and dwelling types. Changes over time are also visualized to provide users a more comprehensive view.\n\nMain R Packages & Functions\n\nggplot2: for descriptive visualization such as boxplots\nggiraph/plotly: for interactive visualization\ngeofacet: for visualization laid out according to the geographic topology\ntimetk: for time series visualization\n\n\n\nApplication Design\n\n\n\n\n\n\n\nClustering Analysis\nClustering analysis is performed to help users identify clusters with distinct consumption patterns. The clustering analysis is done using the consumption data for each planning area and dwelling type over time. This analysis will help stakeholders in future strategic planning activities such as supply planning and pricing.\n\nMain R Packages & Functions\n\ndtwclust: for time series clustering\ndendextend: to visualize and compare hierarchical clustering’s dendrogram\ntmap: representing clusters on interactive map visual\n\n\n\nApplication Design\n\n\n\n\n\nInferential Analysis\nWhen there are more than two sample groups, ANOVA (Analysis of Variance) is used to test if there are statistically significant differences between the means of these independent sample groups. In other words, it compares the means of different samples to determine the influence of one or more factors.\n\nMain R Packages & Functions\n\nggplot2: for descriptive visualization such as boxplots\nggbetweenstats: A combination of box and violin plots along with jittered data points for between-subjects designs with statistical details included in the plot as a subtitle\nggcorrplot: Visualize a correlation matrix using ggplot2. It provides a solution for reordering the correlation matrix and displays the significance level on the correlogram. It includes also a function for computing a matrix of correlation p-values.\n\n\n\nApplication Design\n\n\nTime Series Forecasting\nVarious predictive models are built onto the app for users to forecast the future consumption trends. The model accuracy and confidence level are also made available for users.\n\n\nMain R Packages & Functions\n\nmodeltime: The time series forecasting framework for use with the ‘tidymodels’ ecosystem. Models considered include ARIMA, Exponential Smoothing, SARIMA, Long Short-Term Memory and additional time series models from the ‘forecast’, ‘tseries’ and ‘prophet’ packages.\ntidymodels: a collection of packages for modeling and machine learning using tidyverse principles.\n\n\n\nApplication Design\n\n\n\n\nData\nA data view is introduced to provide the user with an overview of how the data appears. Users will be able to choose which table and columns to display.\n\nVisual Design"
  },
  {
    "objectID": "Proposal.html#project-timeline",
    "href": "Proposal.html#project-timeline",
    "title": "Project Snapshot",
    "section": "Project Timeline",
    "text": "Project Timeline"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html",
    "href": "Shiny_App_G9/Sandbox_cleaned.html",
    "title": "Developer Guideline",
    "section": "",
    "text": "packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', \"tidyr\", \"readr\")\nfor(p in packages){\n  if(!require(p,character.only = T)){\n    install.packages(p)\n  }\n  library(p,character.only = T)\n}"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html#read-data-and-compress-in-rds-file",
    "href": "Shiny_App_G9/Sandbox_cleaned.html#read-data-and-compress-in-rds-file",
    "title": "Developer Guideline",
    "section": "Read data and compress in RDS file",
    "text": "Read data and compress in RDS file\nWe use the readr package in R to read three CSV files and store them as data frames in the variables T2.3, T3.4, and T3.5. Here’s a brief explanation of what each line does:\n\nlibrary(readr): This line loads the readr package, which provides functions for reading and writing delimited files in R.\nT2.3 <- read_csv(\"data/T2-3.csv\"): This line reads the CSV file located at \"data/T2-3.csv\" using the read_csv() function from the readr package. The resulting data frame is stored in the variable T2.3.\nT3.4 <- read_csv(\"data/T3-4.csv\"): This line reads the CSV file located at \"data/T3-4.csv\" using the read_csv() function from the readr package. The resulting data frame is stored in the variable T3.4.\nT3.5 <- read_csv(\"data/T3-5.csv\"): This line reads the CSV file located at \"data/T3-5.csv\" using the read_csv() function from the readr package. The resulting data frame is stored in the variable T3.5.\n\n\n# library(readr)\n\n# Peak System Demand\nT2.3 <- read_csv(\"data/T2-3.csv\")\n# Total Household Electricity Consumption by Dwelling Type\nT3.4 <- read_csv(\"data/T3-4.csv\")\n# Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type\nT3.5 <- read_csv(\"data/T3-5.csv\")\n\n\nData Table\nThis section provides a summary of the data tables utilized in the project, offering insight into the original data’s appearance. The project employs three tables, namely\n\nT2.3 peak system demand\nT3.4 Total household electricity consumption by dwelling type\nT3.5 Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type”\n\nT2.3 : Peak System Demand\n\n\n# A tibble: 5 × 3\n   year   mth peak_system_demand_mw\n  <dbl> <dbl>                 <dbl>\n1  2005     1                  5083\n2  2005     2                  5285\n3  2005     3                  5333\n4  2005     4                  5408\n5  2005     5                  5385\n\n\nT3.4 : Total Household Electricity Consumption by Dwelling Type\n\n\n# A tibble: 5 × 4\n  year  month DWELLING_TYPE consumption_GWh\n  <chr> <chr> <chr>                   <dbl>\n1 2005  1     Overall                  448.\n2 2005  2     Overall                  437.\n3 2005  3     Overall                  480.\n4 2005  4     Overall                  534.\n5 2005  5     Overall                  535 \n\n\nT3.5 : Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type\n\n\n# A tibble: 5 × 6\n  dwelling_type    year month Region         Description    kwh_per_acc\n  <chr>           <dbl> <chr> <chr>          <chr>          <chr>      \n1 1-room / 2-room  2005 1     Central Region Bishan         104.9      \n2 1-room / 2-room  2005 1     Central Region Bukit Merah    140.7      \n3 1-room / 2-room  2005 1     Central Region Central Region 136.5      \n4 1-room / 2-room  2005 1     Central Region Geylang        148.5      \n5 1-room / 2-room  2005 1     Central Region Kallang        115.6"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html#overview",
    "href": "Shiny_App_G9/Sandbox_cleaned.html#overview",
    "title": "Developer Guideline",
    "section": "1 Overview",
    "text": "1 Overview\n\n1.1 Introduction\nThe code uses the shiny and shinydashboard packages to create a web application to analyze and visualize data related to Singapore’s energy consumption.\nThe introtext variable contains a brief introduction to the Singaporean electricity market and the challenges in analyzing it.\nThe ui function creates the user interface for the web application using dashboardPage and dashboardSidebar. The dashboardHeader function sets the title of the web app. The dashboardSidebar function creates a sidebar menu with a single menu item labeled “OVERVIEW”.\nThe dashboardBody function creates a body section with a single tab item labeled “overview”. The navbarPage function creates a navigation bar with a single tab panel labeled “Introduction”. The introtext variable is used as the content of this tab panel.\nThe server function is empty in this code. Additional code would be added to the server function to create interactive features and to perform data analysis and visualization.\n\nlibrary(shiny)\nlibrary(shinydashboard)\n\nintrotext = \"Singapore has progressively moved towards an open electricity market since 2001 \nto ensure a reliable energy supply and promote effective competition in the energy market.\nHowever, it is challenging to analyze the energy market and make informed decisions due to \nseveral variable components that could influence the market. First, the price of electricity \nin the wholesale market fluctuates depending on the electricity demand and supply, which are \ndependent on consumption patterns as well as gas industry respectively. About 95% of electricity \nis generated using natural gas. Next, there are also multiple parties (Electricity Market Authority, \nPower generation companies, Electricity Retailers, etc) involved in the electricity market.\nTo address this challenge, we build this RShinny app to provide relevant stakeholders with means \nto analyse and understand the data with applicable analytics models. Also, we want to help the \nusers explore more information about the Singapore energy market easily through visualizations.\"\n\nui = dashboardPage(\n  dashboardHeader(title = 'Singapore Energy Consumption', titleWidth = 400),\n  \n  dashboardSidebar(width = 210,\n                   sidebarMenu(\n                     menuItem(\" OVERVIEW\", tabName = 'overview',    icon = icon(\"chalkboard-user\"))\n                   )),\n  dashboardBody(\n    tabItems(\n      tabItem(\n        tabName = \"overview\",\n        navbarPage( \"OVERVIEW\",\n                    \n                    tabPanel(\"Introduction\",introtext)\n        )\n      )\n    )\n  )\n)\nserver = function(input, output, session) {}\n\nshinyApp(ui = ui, server = server)\n\n\n\n1.2 Geofacet\nThis code visualizes data related to household electricity consumption in Singapore. The application imports data from the T3.5 table and subsets it to exclude certain regions and types of housing, as well as convert certain columns to appropriate data types. The code then reads a shapefile that represents Singapore’s subzones and imports an area grid data file.\nThe user interface (UI) of the application shows the average monthly household electricity consumption by planning area and dwelling type. The user can choose to fix or free the y-axis scale.\nThe server function includes a reactive expression that groups the data by year, dwelling type, and planning area to compute the average electricity consumption per account. The data is then merged with the area grid data file to obtain the spatial information necessary for plotting. The output plot is generated using ggplot2 and geofacet packages, which enable the use of subplots based on a grid of geographic regions. The output plot is reactive to changes made in the user interface.\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(geofacet)\nlibrary(sf)\n\ntown <- subset(T3.5, Description != 'Overall' & Description !='Central Region' & \n                 Description !='East Region' & Description !='North East Region' &\n                 Description !='North Region' & Description !='West Region' &\n                 kwh_per_acc != 's' & dwelling_type != 'Private Housing' &\n                 dwelling_type != 'Public Housing' & month != 'Annual') %>%\n  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%\n  mutate(date = parse_date_time(paste0(year, \"-\", month,\"-1\"),\"ymd\"))\n\n\n# reading the map file\nmpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',\n                layer = 'MP14_SUBZONE_WEB_PL',\n                crs = 3414)\n\n# Import the area grid data.\narea_grid <- read_csv(\"data/areagrid.csv\")\nsingapore <- st_transform(mpsz, 4326)\n\nui = dashboardPage(\n  dashboardHeader(title = 'Singapore Energy Consumption', titleWidth = 400),\n  \n  dashboardSidebar(width = 210,\n                   sidebarMenu(\n                     menuItem(\" OVERVIEW\", tabName = 'overview',    icon = icon(\"chalkboard-user\"))\n                   )),\n  dashboardBody(\n    tabItems(\n      tabItem(\n        tabName = \"overview\",\n        navbarPage( \"OVERVIEW\",\n                    tabPanel(\"Consumption by Planning Area & Dwelling Type\",\n                            fluidPage(\n                              radioButtons(\"axis\", label = \"select axis control\",\n                                           choices = c(\"fixed y-axis\" = \"fixed\",\n                                                       \"free y-axis\" = \"free_y\"), \n                                           inline = T),\n                              plotOutput(\"geo\", height = 800)\n                            ))\n        )\n      )\n    )\n  )\n)\n\nserver = function(input, output, session) {\n   geofacet <- town %>% \n        group_by(year, dwelling_type, Description)  %>%\n        summarise(average_consumption = mean(kwh_per_acc, na.rm = TRUE))%>%\n        ungroup()\n  geofacet_gas_consump <- inner_join(geofacet, area_grid,\n                                     by = c(\"Description\" = \"name\"))\n  # merge table with town name\n  common_grid <- area_grid[area_grid$name %in% unique(geofacet$Description),]\n  \n  observeEvent(input$axis,{\n    \n    output$geo <- renderPlot ({\n      ggplot(geofacet_gas_consump, aes(x = year, y = average_consumption)) +\n        geom_line(aes(color = as.factor(dwelling_type))) +\n        facet_geo(~Description, grid = common_grid, scales = input$axis) +\n        labs(title = \"Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type\") +\n        theme(plot.title = element_text(size=22),\n              axis.text.x = element_text(size = 10, angle = 45),\n              axis.text.y = element_text(size = 10),\n              strip.text = element_text(size = 10),\n              legend.position = \"right\")\n    })\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n1.3 Consumption by Dwelling type and Town\nThis code loads the data from a data frame “T3.4” and filters it based on certain conditions such as the year, month, and dwelling type. The resulting data frame is stored in a new variable called “dwelling”.\nThe code then adds a new column called “class” to the “dwelling” data frame based on whether the dwelling type is “Private Apartments and Condominiums”, “Landed Properties”, or “Others” or whether it is “1-room / 2-room”, “3-room”, “4-room”, or “5-room and Executive”. The values in the “class” column are set to “Private” or “Public” based on the dwelling type.\nFinally, the “dwelling” data frame is saved as an RDS file called “dwelling.rds” in the “RDS” folder and then read back into the R environment using the “readRDS” function. The first five rows of the resulting data frame are displayed using the “head” function.\n\ndwelling <- T3.4 %>%\n  filter(year %in% c(2005:2022)) %>%\n  filter(month %in% c(1:12)) %>%\n  filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',\n                              '5-room and Executive',\n                              'Private Apartments and Condominiums',\n                              'Landed Properties', 'Others')) %>%\n  mutate(date = parse_date_time(paste0(year, \"-\", month,\"-1\"),\"ymd\"))\n\n#Add Private vs Public Classification\ndwelling$class <- case_when(\n    dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',\n                                 'Landed Properties', 'Others') ~ \"Private\",\n    dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',\n                                  '5-room and Executive') ~ \"Public\")\n\nsaveRDS(dwelling, file = \"RDS/dwelling.rds\")\n\ndwelling <- readRDS(file = \"RDS/dwelling.rds\") # intro\n\nhead(dwelling, 5)\n\n# A tibble: 5 × 6\n  year  month DWELLING_TYPE   consumption_GWh date                class \n  <chr> <chr> <chr>                     <dbl> <dttm>              <chr> \n1 2005  1     1-room / 2-room             6.3 2005-01-01 00:00:00 Public\n2 2005  2     1-room / 2-room             6   2005-02-01 00:00:00 Public\n3 2005  3     1-room / 2-room             6.1 2005-03-01 00:00:00 Public\n4 2005  4     1-room / 2-room             6.9 2005-04-01 00:00:00 Public\n5 2005  5     1-room / 2-room             6.8 2005-05-01 00:00:00 Public\n\n\nThis code is processing and filtering data related to electricity consumption in different towns, and then saving the selected data to an RDS file.\nThe code starts by subsetting a data frame called T3.5 using the subset() function. The resulting data frame is called “town”. The subset() function removes rows with certain conditions using logical operators. Rows where the “Description” column is equal to ‘Overall’, ‘Central Region’, ‘East Region’, ‘North East Region’, ‘North Region’, ‘West Region’ are removed. Rows with ‘s’ in the “kwh_per_acc” column and rows where the “dwelling_type” column is equal to ‘Private Housing’ or ‘Public Housing’ are also removed. Finally, rows with the “month” column equal to ‘Annual’ are removed.\nThe next step is to mutate the “town” data frame. First, the “kwh_per_acc” column is converted to numeric using the as.numeric() function. Next, a new “date” column is created by combining the “year” and “month” columns and converting it to a date using the parse_date_time() function.\nThe “town” data frame is then grouped by “date” and “Description” columns and the “summarise” function is used to calculate the sum of “kwh_per_acc” divided by 1000. The resulting data frame is called “town_final”.\nThe “town_final” data frame is then manipulated using the pipe operator (%>%) and several mutate() functions. First, a new column called “type” is created by copying the “Description” column. Then, a new column called “title” is created with the value ‘Town’. The “year” and “month” columns are extracted from the “date” column using the year() and month() functions. Finally, a new data frame is created by selecting only certain columns.\nThe resulting data frame is saved to an RDS file using the saveRDS() function. Finally, the first five rows of the resulting data frame are printed using the head() function.\n\ntown <- subset(T3.5, Description != 'Overall' & Description !='Central Region' & \n                 Description !='East Region' & Description !='North East Region' &\n                 Description !='North Region' & Description !='West Region' &\n                 kwh_per_acc != 's' & dwelling_type != 'Private Housing' &\n                 dwelling_type != 'Public Housing' & month != 'Annual') %>%\n  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%\n  mutate(date = parse_date_time(paste0(year, \"-\", month,\"-1\"),\"ymd\"))\n\ntown_final <- town %>% \n  group_by(date, Description) %>%\n  summarise(consumption = sum(kwh_per_acc)/1000)\n\nregion <- town %>% \n  group_by(date, Region) %>% \n  summarise(consumption = sum(kwh_per_acc)/1000)\n\nchosendata <- town_final %>%\n  mutate(type = Description) %>%\n  mutate(title = 'Town') %>%\n  mutate(year = year(date)) %>%\n  mutate (month = month(date)) %>%\n  select(c('year','month','date','type','consumption','title'))\nsaveRDS(chosendata, file = \"RDS/chosendata.rds\")\n\nhead(chosendata, 5)\n\n# A tibble: 5 × 6\n# Groups:   date [1]\n   year month date                type        consumption title\n  <dbl> <dbl> <dttm>              <chr>             <dbl> <chr>\n1  2005     1 2005-01-01 00:00:00 Ang Mo Kio         1.65 Town \n2  2005     1 2005-01-01 00:00:00 Bedok              2.05 Town \n3  2005     1 2005-01-01 00:00:00 Bishan             1.79 Town \n4  2005     1 2005-01-01 00:00:00 Bukit Batok        1.87 Town \n5  2005     1 2005-01-01 00:00:00 Bukit Merah        2.56 Town \n\n\n\ndwelling_tog <- dwelling %>%\n  mutate(type = DWELLING_TYPE) %>%\n  mutate(consumption = consumption_GWh) %>%\n  mutate(title = 'Dwelling Type') %>%\n  select(c('year','month','date','type','consumption','class', 'title'))\nsaveRDS(dwelling_tog, file = \"RDS/dwelling_tog.rds\")\n\ntown_tog <- town_final %>%\n  mutate(type = Description) %>%\n  mutate(title = 'Town') %>%\n  mutate(year = year(date)) %>%\n  mutate (month = month(date)) %>%\n  select(c('year','month','date','type','consumption','title'))\nsaveRDS(town_tog, file = \"RDS/town_tog.rds\")\n\nregion_tog <- region %>%\n  mutate(type = Region) %>%\n  mutate(title = 'Region') %>%\n  mutate(year = year(date)) %>%\n  mutate (month = month(date)) %>%\n  mutate(unit = 'kWh') %>%\n  select(c('year','month','date','type','consumption','title'))\nsaveRDS(region_tog, file = \"RDS/region_tog.rds\")\n\n\nPlot 1 - Line plot\nThis code creates a line plot using ggplot to show the electricity consumption over time for a chosen data set. The data is stored in the RDS file “chosendata.rds” and is loaded using the readRDS() function.\nThe ggplot() function is called and the data argument is set to chosendata, which contains the data to be plotted. The aes() function is used to specify the aesthetics of the plot. The x-axis is set to date and the y-axis is set to consumption, with lines colored according to the type of consumption.\nThe geom_line() function is called to add the lines to the plot. The labs() function is used to add a title to the plot, as well as labels for the x and y axes. The scale_color_discrete() function is used to change the name of the legend for the line colors, and the theme() function is used to change the position of the legend to the bottom of the plot.\n\nchosendata <- readRDS(file = \"RDS/chosendata.rds\") # intro\nggplot(data = chosendata, aes(x = date)) +\n  geom_line(aes(y = consumption, colour = type)) + \n  labs(title = paste0(\"Electricity Consumption by \",chosendata[1,6]),\n      x = \"Year\", y = paste0(\"Consumption, GWh \")) +\n  scale_color_discrete(name=\"\") +\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n#choose between dwelling_tog, town_tog, region_tog\nchosendata <- town_tog\n\n#choosing the time period\nstartyear <- 2005\nendyear <- 2021\n\n\nlibrary(ggstatsplot)\ntown <- readRDS(file = \"RDS/town.rds\") \n\n ggbetweenstats(\n data = town |> filter(town$Region %in% c(\"Central Region\")),\n x = Description,\n y = kwh_per_acc,\n type = \"nonparametric\",\n p.adjust.method = \"fdr\",\nmessages = FALSE\n )\n\n\n\n\n\n\nPlot 2 - Cycle plot\nThe code creates a cycle plot for electricity consumption in a specific location and dwelling type using the ggplot2 package.\nThe first line of code defines a variable select_type that specifies the type of dwelling to be plotted. This is followed by a data manipulation pipeline using dplyr to filter the data for the specified dwelling type and format the year and month variables as factors with specific levels.\nThe next section of code computes the average consumption per month across all years for the selected dwelling type and stores this in the hline.data variable.\nThe final section of code creates the cycle plot using ggplot2. The geom_line function is used to plot the electricity consumption data over time for each month, with each month represented by a different color. The geom_hline function adds a horizontal line representing the average consumption for each month across all years. The facet_grid function is used to split the plot into individual panels for each month. The theme function is used to adjust the appearance of the plot, such as the angle of the x-axis text labels. The labs function is used to add a title and subtitle to the plot, with the subtitle indicating the specific dwelling type being plotted. Finally, the scale_x_discrete function is used to set the x-axis breaks to specific years and the xlab and ylab functions are used to label the x and y axes, respectively.\n\nselect_type <- 'Bishan'\nselect_cycle <- chosendata %>% \n  filter(type %in% c(select_type)) %>%\n  mutate(year = factor(year, levels = 2005:2022),\n         month = factor(month, levels = 1:12))\n\n#Computing year average by months\nhline.data <- select_cycle %>%\n  group_by(month) %>%\n  summarise(avg_cons = mean(consumption))\n\n#Plotting cycle plot for electricity consumption per dwelling type\nggplot() + \n  geom_line(data = select_cycle,\n            aes(x=year,y=consumption, group=month), colour = \"black\") +\n  geom_hline(data = hline.data,\n             aes(yintercept=avg_cons),\n             linetype=6, \n             colour=\"red\", \n             linewidth=0.5) +\n  facet_grid(~month) +\n  theme(axis.text.x = element_text(angle=90, vjust=1, hjust=1)) +\n  labs(title = paste0(\"Cycleplot for Chosen \",chosendata[1,6],\"'s Consumption (GWh) , Jan 2005-Jun 2022\"),\n       subtitle = paste0(chosendata[1,6],\": \",select_type)) +\n  scale_x_discrete(breaks=c(\"2005\",\"2010\",\"2015\",\"2020\")) +\n  xlab(\"\") +\n  ylab(\"Consumption, GWh\")\n\n\n\n\n\n\nPlot 3 - Sparkline Table\n\nlibrary(gtExtras)\nlibrary(svglite)\n#Preparing the data for report \nd_report <- chosendata %>%   \n  filter(year %in% c(startyear:endyear)) %>%   \n  mutate(`Category`= type) %>%   \n  group_by(`Category`) %>%   \n  summarise(\"Min\" = min(consumption, na.rm = T),             \n            \"Max\" = max(consumption, na.rm = T),\n            \"Average\" = mean(consumption, na.rm = T)) \n\nd_sparks <- chosendata %>%   \n  filter(year %in% c(startyear:endyear)) %>%   \n  mutate(`Category`= type) %>%   \n  group_by(`Category`) %>%   \n  summarize(`Monthly Consumption` = list(consumption))\nsaveRDS(d_sparks, file = \"RDS/d_sparks.rds\")\n\nreport_data = left_join(d_report, d_sparks)\nreport_data$Average <- round(report_data$Average , 2)\nreport_data$Min <- round(report_data$Min , 2)\nreport_data$Max <- round(report_data$Max , 2)\nsaveRDS(report_data, file = \"RDS/report_data.rds\")\n\nhead(report_data, 5)\n\n# A tibble: 5 × 5\n  Category      Min   Max Average `Monthly Consumption`\n  <chr>       <dbl> <dbl>   <dbl> <list>               \n1 Ang Mo Kio   1.54  4.04    2.26 <dbl [204]>          \n2 Bedok        1.91  4.38    2.57 <dbl [204]>          \n3 Bishan       1.67  4.01    2.33 <dbl [204]>          \n4 Bukit Batok  1.73  4.34    2.32 <dbl [204]>          \n5 Bukit Merah  1.83  4.42    2.75 <dbl [204]>          \n\n\n\n\nPlot 4 - Slopegraph"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html#clustering",
    "href": "Shiny_App_G9/Sandbox_cleaned.html#clustering",
    "title": "Developer Guideline",
    "section": "2. Clustering",
    "text": "2. Clustering\n\n2.1 Hierachical clustering\nThis code reads in a CSV file named “T3-5.csv” using the read_csv function from the readr package. It then applies several data transformations to create a new data frame named clus and saves both the original and transformed data frames as RDS files.\nFirst, the code filters out any rows where the month is “Annual”, the year is before 2018, the dwelling type is “Overall”, or the description column contains the strings “Region”, “Pioneer”, or “Overall”. The resulting data frame is stored in clus_data.\nNext, the code transforms the kwh_per_acc column from character to numeric format using as.numeric(). It also creates a new column named date by concatenating the year and month columns and parsing them as dates using the parse_date_time() function from the lubridate package. The month and year columns are then removed using the subset() function.\nThe pivot_wider() function from the tidyr package is used to pivot the clus_data data frame wider so that the kwh_per_acc values for each date become their own column. The resulting data frame is stored in clus.\nFinally, any rows with missing values are removed using na.omit(), and the Description column is moved to be the first column in the data frame using the relocate() function from the dplyr package. The resulting data frames, clus_data and clus, are saved as RDS files.\nAfter saving the data frames, the code reads them back in using the readRDS() function and displays the first five rows of each data frame using head().\n\nlibrary(lubridate)\n\nT3.5 <- read_csv(\"data/T3-5.csv\")\nclus_data <- T3.5 %>% \n  filter(month != \"Annual\" & \n           year > 2017 & \n           dwelling_type != \"Overall\" &\n           !str_detect(Description,\"Region|Pioneer|Overall\"))\n\n# transform dataset\n# convert kwh into numbers\nclus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)\n# join month and year into a date\nclus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c(\"%Y %m\")) \n\n# drop month and year column\nclus_data <- subset(clus_data, select=-c(month, year, Region)) %>%\n  arrange(date)\n\n# pivot wider\nclus <- clus_data %>%\n  pivot_wider(names_from=date, values_from=kwh_per_acc) \n\n# omit na\nclus <- na.omit(clus)\nclus <- clus %>% relocate(Description, .before = dwelling_type)\n\nsaveRDS(clus_data, file = \"RDS/clus_data.rds\")\nsaveRDS(clus, file = \"RDS/clus.rds\")\n\nclus_data <- readRDS(file = \"RDS/clus_data.rds\") # clustering\nclus <- readRDS(file = \"RDS/clus.rds\") # clustering\nhead(clus_data, 5)\n\n# A tibble: 5 × 4\n  dwelling_type   Description kwh_per_acc date               \n  <chr>           <chr>             <dbl> <dttm>             \n1 1-room / 2-room Bishan             133. 2018-01-01 00:00:00\n2 1-room / 2-room Bukit Merah        160. 2018-01-01 00:00:00\n3 1-room / 2-room Bukit Timah        123. 2018-01-01 00:00:00\n4 1-room / 2-room Geylang            170. 2018-01-01 00:00:00\n5 1-room / 2-room Kallang            134. 2018-01-01 00:00:00\n\nhead(clus, 5)\n\n# A tibble: 5 × 56\n  Description dwelling…¹ 2018-…² 2018-…³ 2018-…⁴ 2018-…⁵ 2018-…⁶ 2018-…⁷ 2018-…⁸\n  <chr>       <chr>        <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 Bishan      1-room / …    133.    123.    122     138.    140.    162.    148 \n2 Bukit Merah 1-room / …    160.    145.    136.    154.    164.    164.    164.\n3 Bukit Timah 1-room / …    123.    130.    137.    140     138.    148.    139.\n4 Geylang     1-room / …    170.    147.    152.    168     167.    198.    175 \n5 Kallang     1-room / …    134.    131     123.    139.    153     160.    150.\n# … with 47 more variables: `2018-08-01` <dbl>, `2018-09-01` <dbl>,\n#   `2018-10-01` <dbl>, `2018-11-01` <dbl>, `2018-12-01` <dbl>,\n#   `2019-01-01` <dbl>, `2019-02-01` <dbl>, `2019-03-01` <dbl>,\n#   `2019-04-01` <dbl>, `2019-05-01` <dbl>, `2019-06-01` <dbl>,\n#   `2019-07-01` <dbl>, `2019-08-01` <dbl>, `2019-09-01` <dbl>,\n#   `2019-10-01` <dbl>, `2019-11-01` <dbl>, `2019-12-01` <dbl>,\n#   `2020-01-01` <dbl>, `2020-02-01` <dbl>, `2020-03-01` <dbl>, …\n\n\n\nPlot 1 - Method selection table\nThis code calculates the clustering distance matrix using the “maximum” method on a normalized data frame (clus_group1) which summarizes the electricity consumption data by Description. The dist() function computes the Euclidean distances between each pair of rows in the input matrix, which is then used to generate a hierarchical clustering using the hclust() function. The normalize() function is used to normalize the input data, so that each variable has zero mean and unit variance. The resulting clustering distance matrix is stored in the clustering variable, which will be used to find the optimal number of clusters using the elbow method. The dendextend and BBmisc packages are loaded, which provide functions to manipulate and plot dendrograms.\n\n# once user have gotten the clustering method from above, they need to input that to find the optimal number of k\nlibrary(dendextend)\nlibrary(BBmisc)\nclus_group1 <- clus[,-c(2)] %>%\n  group_by(Description) %>%\n  summarise_each(list(sum))\n\nclustering <- dist(normalize(clus_group1[, -1]),  method = \"maximum\")\ndend_expend(clustering)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6394564\n2      unknown        ward.D2 0.7218247\n3      unknown         single 0.8325438\n4      unknown       complete 0.8976064\n5      unknown        average 0.9123991\n6      unknown       mcquitty 0.9094702\n7      unknown         median 0.8238489\n8      unknown       centroid 0.8998871\n\n\n\n\nPlot 2 - Heatmap\nThis code generates a heatmaply visualization of the hierarchical clustering results for the energy consumption data of different towns over time. The data is first summarized by taking the sum of energy consumption for each town across time. The resulting data frame is then converted to a matrix, which is used to generate the heatmaply plot.\nThe heatmaply function is called with several arguments, including:\n\nclus_matrix1: the matrix of energy consumption data to be visualized\nscale: the scaling method to be used (in this case, column scaling is used)\ndist_method: the distance metric to be used for clustering (in this case, Euclidean distance is used)\nhclust_method: the hierarchical clustering method to be used (in this case, average linkage is used)\nColv: whether to show a column dendrogram (in this case, set to NA to not show)\nseriate: the seriation method to be used (in this case, set to “none” to not reorder rows and columns)\nk_row: the number of clusters to show in the row dendrogram (in this case, set to 3)\nmargins: the size of the margins (in this case, set to c(NA,200,50,NA))\ncolors: the color scheme to be used (in this case, viridis with 256 colors)\nfontsize_row: the font size for row labels\nfontsize_col: the font size for column labels\nmain: the main title for the plot\nylab: the y-axis label for the plot\nxlab: the x-axis label for the plot\n\n\nlibrary(heatmaply)\nclus_group1 <- clus[,-c(2)] %>%\n  group_by(Description) %>%\n  summarise_each(list(sum))\n\n# making \"Description\" the row name (index)\nrow.names(clus_group1) <- clus_group1$Description\n\n# Making it into a matrix\nclus_matrix1 <- data.matrix(clus_group1)\n\n# plot\nheatmaply(clus_matrix1[,-c(1)],\n          scale = \"column\",\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          Colv=NA,\n          seriate = \"none\",\n          k_row = 3,\n          margins = c(NA,200,50,NA),\n          colors = viridis(\n            n= 256, alpha=1, \n            begin=0, end=1,\n            option=\"viridis\"),\n          fontsize_row = 5,\n          fontsize_col = 5,\n          main=\"Hierarchical Clustering\",\n          ylab = \"Towns\",\n          xlab = \"Time\")\n\n\n\n\n\n\n\nPlot 3 - Number of cluster plot\nThis code is creating a plot to determine the optimal number of clusters (k) based on the hierarchical clustering method applied earlier.\nThe first line creates a hierarchical clustering object using the hclust function, with the distance matrix obtained from dist and the McQuitty linkage method.\nThe second line uses the find_k function from the BBmisc package to calculate the optimal number of clusters based on the within-cluster sum of squares (WSS) method. This function takes the hierarchical clustering object as input and returns the optimal number of clusters.\nFinally, the third line creates a plot of the number of clusters against the WSS values using the plot function. The warning and message arguments are set to FALSE to suppress any warnings or messages that might be produced during the plot creation.\n\nclust2 <- hclust(clustering, method = \"mcquitty\")\nnum_k <- find_k(clust2)\nplot(num_k)\n\n\n\n\n\n\nPlot 4 - Map\nThis code generates a choropleth map that shows the clustering result on a map of Singapore.\nFirst, the code reads in a map file of Singapore, which contains the boundaries of subzones, and transforms the map to a common coordinate reference system (CRS). Then, the clustering result is joined with the map data based on the name of the subzones.\nNext, the code uses the tmap package to create a choropleth map. The tm_shape() function sets the shape object to be the joined map data. The tm_fill() function fills the shapes with colors based on the cluster column, and the id parameter specifies the column to use for the map’s IDs. The style parameter specifies the type of binning method to use, and the palette parameter sets the color palette to use for the map. Finally, the tm_borders() function adds borders to the shapes with an alpha value of 0.7.\nThe tmap_mode(\"view\") function is used to set the plot mode to interactive, which allows the user to zoom and pan around the map.\n\n## Add clusters to dataframe\n\nnum_clus <- cutree(clust2, k=3)\nclus_hc <- cbind(clus_group1, cluster = as.factor(num_clus))\n\nlibrary(sf)\n# reading the map file\nmpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',\n                layer = 'MP14_SUBZONE_WEB_PL',\n                crs = 3414) \n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `E:\\ISSS608_VisualAnalytics\\ISSS608-GroupProject\\Shiny_App_G9\\master-plan-2014-subzone-boundary-web-shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n\nsingapore <- st_transform(mpsz, 4326)\n\nlibrary(tmap)\n# change Description to upper case\nclus_hc$Description <- toupper(clus_hc$Description)\n\n# Preparing the choropleth map\nmpsz_clus <- left_join(singapore, clus_hc, by = c(\"PLN_AREA_N\" = \"Description\"))\ntmap_mode(\"view\")\ntm_shape(mpsz_clus)+\n  tmap_options(check.and.fix = TRUE)+\n  tm_fill(\"cluster\", id=paste(\"PLN_AREA_N\"),\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.7)\n\n\n\n\n\n\n\n\n\n2.2 Time Series clustering\nThis code performs time series clustering analysis and visualization for Singapore’s subzones based on the Dynamic Time Warping (DTW) algorithm. The data is preprocessed and clustered using the tsclust function from the dtwclust package, where the input parameters include the type of clustering method, the number of clusters, distance function, hierarchical clustering method, and additional arguments for distance function. The resulting clusters are added to the original data frame using left_join.\nThe time series data is transformed from wide to long format using the gather function and plotted using the plot_time_series function from the timetk package. The time series plot is faceted by cluster and includes a plotly slider for interactive visualization.\nThe resulting clusters are visualized using a choropleth map of Singapore’s subzones. The map is created using the tmap package, where the subzones are joined with the clustered data using left_join and then plotted using the tm_fill function. The subzones are colored according to the cluster group using a green color palette, and subzone borders are added with an alpha value of 0.7.\n\nlibrary(dtwclust)\nlibrary(tibble)\nlibrary(ggdendro)\n\n# Clustering Method (type) (\"partitional\", \"hierarchical\", \"tadpole\", \"fuzzy\".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods\n# parameter 1: Number of cluster (k)\n# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust\n# parameter 3: hierarchical clustering method (\"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\" or \"centroid\" .)\n\n\ncluster_dtw <- tsclust(clus_matrix1[,-c(1)],\n                       type = \"h\", \n                       k=2,\n                       distance=\"dtw\",\n                       control = hierarchical_control(method = \"ward.D\"),\n                       preproc = NULL,\n                       args=tsclust_args(dist = list(window.size = 5L)))\n\nhclus_dtw <- cutree(cluster_dtw, k=4) %>%\n  as.data.frame(.) %>%\n  rename(.,cluster_group = .) %>%\n  rownames_to_column(\"type_col\")\n\n# hcdata <- dendro_data(cluster_dtw)\n# names_order <- hcdata$labels$label\n\nlibrary(ggplot2)\nlibrary(ggiraph)\nlibrary(timetk)\n\n# add the cluster number\ndtw_cluster <- clus_group1 %>%\n  left_join(hclus_dtw, by=c(\"Description\" = \"type_col\")) \n\n# change date columns into rows\ndtw_cluster_t <- dtw_cluster %>%\n  mutate_at(vars(contains(\"202\")),as.numeric) %>%\n  gather(Date, value, 2:55)\n\n# Add the word \"Cluster\"\ndtw_cluster_t$cluster_group <- paste(\"Cluster\", dtw_cluster_t$cluster_group)\n\n# convert Date into date format\ndtw_cluster_t$Date <- parse_date_time(dtw_cluster_t$Date, orders=c(\"%Y-%m-%d\")) \n\n# plot time series by cluster\n\nts <- plot_time_series(.data=dtw_cluster_t,\n                 .date_var=Date, \n                 .value=value,\n                 .color_var=Description,\n                 .facet_var=cluster_group,\n                 .facet_ncol=2,\n                 .facet_scales = \"free_y\",\n                 .smooth=FALSE,\n                 .line_size = 0.3,\n                 .plotly_slider = TRUE,\n                 .title = \"Time Series Plot by cluster\") \n\nts <- ts %>%\n  layout(hovermode=\"x\",\n         hoverlabel=list(font=list(size=7)))\nts\n\n\n\n\n# how to modify the tooltip? Town is being shown twice here...\n\nlibrary(sf)\n# reading the map file\nmpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',\n                layer = 'MP14_SUBZONE_WEB_PL',\n                crs = 3414) \n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `E:\\ISSS608_VisualAnalytics\\ISSS608-GroupProject\\Shiny_App_G9\\master-plan-2014-subzone-boundary-web-shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n\nsingapore <- st_transform(mpsz, 4326)\n\nlibrary(tmap)\n# change Description to upper case\ndtw_cluster_t$Description <- toupper(dtw_cluster_t$Description)\n\n# Preparing the choropleth map\nmpsz_clus_dtw <- left_join(singapore, dtw_cluster_t, by = c(\"PLN_AREA_N\" = \"Description\"))\ntmap_mode(\"view\")\ntm_shape(mpsz_clus_dtw)+\n  tmap_options(check.and.fix = TRUE)+\n  tm_fill(\"cluster_group\", id=paste(\"PLN_AREA_N\"),\n          style = \"pretty\",\n          palette = \"Greens\") +\n  tm_borders(alpha = 0.7)"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html#inferential---anova",
    "href": "Shiny_App_G9/Sandbox_cleaned.html#inferential---anova",
    "title": "Developer Guideline",
    "section": "3. Inferential - ANOVA",
    "text": "3. Inferential - ANOVA\nThe first part of the code reads data from several RDS files, including T3-5.rds that contains monthly household electricity consumption data by planning area and dwelling type. The data is saved into a new variable named consumption, which is then modified using mutate to convert kwh_per_acc to a numeric variable and year to a character variable. The modified consumption data is then saved into an RDS file named anova.rds.\nThe next part of the code installs and loads several packages using a for loop that checks whether each package is installed and installs it if it is not.\nThe UI section of the code creates a dashboard with a sidebar menu and a tab for inferential statistics. The inferential statistics tab has a sub-menu with a single option for ANOVA. The ANOVA tab has two rows, each with two columns. The left column in the first row contains a pickerInput element that allows the user to select a parameter (dwelling_type, Region, or year) and a verbatimTextOutput element that displays ANOVA statistics for the selected parameter. The right column in the first row contains a plotOutput element that displays a boxplot of kwh_per_acc by planning area. The left column in the second row contains a pickerInput element that allows the user to select a region (Central Region, North East Region, East Region, North Region, or West Region) and a verbatimTextOutput element that displays ANOVA statistics for the selected region. The right column in the second row contains a plotOutput element that displays a boxplot of kwh_per_acc by dwelling type.\nThe server section of the code defines the behavior of the dashboard. It starts by loading the consumption data from the anova.rds file and modifying it as described earlier. The server then defines an observeEvent function that listens for changes in the anovainput pickerInput element. Depending on the selected parameter, the function generates a boxplot of kwh_per_acc by planning area or dwelling type, or ANOVA statistics for the selected parameter. The output is displayed in the corresponding plotOutput or verbatimTextOutput element.\n\nT3.5 <- readRDS(file = \"RDS/T3-5.rds\")\nconsumption <- T3.5\nconsumption <- consumption %>% \n  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>% \n  mutate(year = as.character(year))\nsaveRDS(consumption, file = \"RDS/anova.rds\")\n\n\n3.1 Box plot anova\nThe “ANOVA” sub-tab uses the ggstatsplot package to create boxplots and ANOVA tables for different variables related to energy consumption. Users can select a variable from a picker input, and the dashboard will display the appropriate boxplot and ANOVA table based on the user’s selection.\nThe code reads in several data files, including data on peak system demand, household electricity consumption, dwelling types, and planning areas. It also imports a map file and area grid data.\nThe ui function creates the dashboard’s user interface, while the server function contains the server-side logic for generating the dashboard’s content based on user inputs.\n\n# LIBRARY -----------------------------------------------------------------\n# library(forecast)\n# library(dplyr)\n# library(tidyr)\n# library(tidyverse)\n\npackages = c('dplyr', 'ggplot2',\n             'ggstatsplot', 'ggrepel', 'ggridges', 'gt', 'gtExtras',\n             'knitr','plotly', 'lubridate', 'psych','ggstatsplot',\n             'reactablefmtr', 'readr', 'sf', 'shiny', 'shinydashboard',\n             'shinythemes', 'shinyWidgets', 'stats', 'tibble', 'tidymodels',\n             'tidyquant', 'tidyr', 'tidyverse'\n            )\n\nfor(p in packages){\n  if(!require(p,character.only = T)){\n    install.packages(p)\n  }\n  library(p,character.only = T)\n}\n\n# READ DATA ---------------------------------------------------------------\n## Read compressed data file\nT2.3 <- readRDS(file = \"RDS/T2-3.rds\") # Peak System Demand\nT3.4 <- readRDS(file = \"RDS/T3-4.rds\") # Total Household Electricity Consumption by Dwelling Type\nT3.5 <- readRDS(file = \"RDS/T3-5.rds\") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type\ndwelling <- readRDS(file = \"RDS/dwelling.rds\")\ntown <- readRDS(file = \"RDS/town.rds\")\n\n# reading the map file\nmpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',\n                layer = 'MP14_SUBZONE_WEB_PL',\n                crs = 3414)\n\n# Import the area grid data.\narea_grid <- read_csv(\"data/areagrid.csv\")\nsingapore <- st_transform(mpsz, 4326)\n\n\n# PARAMETER ---------------------------------------------------------------\nyears <- c(\"2022\",\"2021\", \"2020\", \"2019\", \"2018\", \"2017\")\nregions <- c( \"Central Region\", \"North East Region\", \"East Region\", \"North Region\", \"West Region\")\n\n\n# UI ----------------------------------------------------------------------\nui = dashboardPage(\n  dashboardHeader(title = 'Singapore Energy Consumption', titleWidth = 400),\n  \n  dashboardSidebar(width = 210,\n                   sidebarMenu(\n                     menuItem(\" INFERENTIAL STATISTICS\",  \n                              tabName = \"inferential\", \n                              icon = icon(\"magnifying-glass-chart\")\n                              )\n                   )\n  ),\n  dashboardBody(\n    tabItems(\n      \n      ## 3 INFERENTIAL STATISTICS ------------------------------------------------\n      tabItem(\n        tabName = \"inferential\",\n        navbarPage(\"INFERENTIAL STATISTICS\", \n                   \n                   ### 3.1 anova ---------------------------------------------\n                   tabPanel(\"ANOVA\",\n                            fluidPage(\n                              fluidRow(\n                                column(5,\n                                       pickerInput(inputId = \"anovainput\", \n                                                   label = \"Select Parameter\",\n                                                   choices = c(\"dwelling_type\", \"Region\", \"year\"), \n                                                   selected = \"dwelling_type\",\n                                                   options = list(`actions-box` = TRUE), \n                                                   multiple = F),\n                                       verbatimTextOutput(\"anovastat\")\n                                ),\n                                column(7, plotOutput(\"dwellingstat\"))\n                              ),\n                              \n                              fluidRow(\n                                column(5,\n                                       pickerInput(inputId = \"region\", \n                                                   label = \"Select Region\",\n                                                   choices = regions, \n                                                   selected = \"Central Region\",\n                                                   options = list(`actions-box` = TRUE), \n                                                   multiple = F),\n                                       verbatimTextOutput(\"anovastat2\")\n                                ),\n                                column(7, plotOutput(\"dwellingstat2\"))\n                              )\n                            ))\n        ))\n    ) #close tabItems\n  ) #close dashboard body\n) #close UI\n\n# SERVER ------------------------------------------------------------------\n\nserver = function(input, output, session) {\n  \n  # anova -----------------------------------------------------------------\n  consumption <- T3.5\n  consumption <- consumption %>% \n    mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>% \n    mutate(year = as.character(year))\n  \n  observeEvent(input$anovainput,{\n    if(input$anovainput == \"Region\"){output$dwellingstat <- renderPlot({\n      consumption %>%\n        mutate(class = fct_reorder(Region, kwh_per_acc, .fun='mean')) %>%\n        ggplot( aes(x=reorder(Region, kwh_per_acc), y=kwh_per_acc)) +\n        geom_boxplot() +\n        stat_summary(fun.y=mean, geom=\"point\", color=\"red\") +\n        theme(legend.position=\"none\") +\n        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +\n        ggtitle(\"Boxplot of consumption per planning area\")\n    })\n    }\n    if(input$anovainput == \"year\") {\n  output$dwellingstat <- renderPlot({\n    ggbetweenstats(\n  data = consumption,\n  x = year,\n  y = kwh_per_acc,\n  # type = \"np\",\n  messages = FALSE\n)\n})}\n    if(input$anovainput == \"dwelling_type\"){output$dwellingstat <- renderPlot({\n      consumption %>%\n        mutate(class = fct_reorder(dwelling_type, kwh_per_acc, .fun='mean')) %>%\n        ggplot( aes(x=reorder(dwelling_type, kwh_per_acc), y=kwh_per_acc)) +\n        geom_boxplot() +\n        stat_summary(fun.y=mean, geom=\"point\", color=\"red\") +\n        theme(legend.position=\"none\") +\n        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +\n        ggtitle(\"Boxplot of consumption per planning area\")\n    })}\n    if(input$anovainput == \"dwelling_type\"){\n      output$anovastat <- renderPrint({\n        summary(aov(kwh_per_acc ~ dwelling_type, data = consumption))\n      })}\n    if(input$anovainput == \"Region\"){\n      output$anovastat <- renderPrint({\n        summary(aov(kwh_per_acc ~ Region, data = consumption))\n      })}\n    if(input$anovainput == \"year\"){\n      output$anovastat <- renderPrint({\n        summary(aov(kwh_per_acc ~ year, data = consumption))\n      })}\n  })\n  \n  # anova2 ---------------------------------------------------------------------\n  observeEvent(input$region,{\n    output$dwellingstat2 <- renderPlot({\n      consumption %>%\n        filter(Region==input$region) %>% \n        mutate(class = fct_reorder(Description, kwh_per_acc, .fun='mean')) %>%\n        ggplot( aes(x=reorder(Description, kwh_per_acc), y=kwh_per_acc)) +\n        geom_boxplot() +\n        stat_summary(fun.y=mean, geom=\"point\", color=\"red\") +\n        theme(legend.position=\"none\") +\n        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +\n        ggtitle(\"Boxplot of consumption per planning area\")\n    })\n    \n    output$anovastat2 <- renderPrint({\n      consumption %>% \n        filter(Region == input$region)\n      summary(aov(kwh_per_acc ~ Description, data = consumption))\n    })\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n3.2 Betweenstats plot anova\nThis code first loads the “ggstatsplot” package and then reads in a dataset called “consumption” from a RDS file located in the “RDS” directory.\nThe ggstatsplot function “ggbarstats” is then used to create a bar plot with error bars to visualize the mean and confidence intervals of the “kwh_per_acc” variable across different levels of the “Region” variable.\nThe “data” argument specifies the dataset to be used, “x” specifies the variable to be plotted on the x-axis (Region), and “y” specifies the variable to be plotted on the y-axis (kwh_per_acc). The “messages” argument is set to FALSE to suppress any messages that may be generated during the plot creation process.\nNote that while the code itself doesn’t include an ANOVA test, one could perform an ANOVA on this data outside of this code to determine if there are significant differences in the mean kwh_per_acc values between the different regions.\n\nlibrary(ggstatsplot)\ntown <- readRDS(file = \"RDS/town.rds\") # Geofacet\n\n    ggbetweenstats(\n          data = town,\n          x = Region,\n          y = kwh_per_acc,\n          messages = FALSE\n        )"
  },
  {
    "objectID": "Shiny_App_G9/Sandbox_cleaned.html#time-series-forecasting",
    "href": "Shiny_App_G9/Sandbox_cleaned.html#time-series-forecasting",
    "title": "Developer Guideline",
    "section": "4. Time series forecasting",
    "text": "4. Time series forecasting\n\npackages = c('tidyverse','tidyquant','tsibbledata','tsibble','feasts'\n             ,'stats','lubridate','data.table','rmarkdown','knitr')\nfor (p in packages) {\n  if(!require(p,character.only = T)){\n    install.packages(p)\n  }\n  library(p,character.only = T)\n}\n\n\narima <- T2.3\narima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), \"%Y %m\"))\narima2 <- T3.4\narima2$Date <- yearmonth(as.yearmon(paste(arima2$year, arima2$month), \"%Y %m\"))\narima2 <- arima2 %>% \n  filter(month != \"Annual\") %>% \n  group_by(Date) %>% \n  summarise(sum = sum(consumption_GWh))\n\n\nsaveRDS(arima, file = \"RDS/arima.rds\")\nsaveRDS(arima2, file = \"RDS/arima2.rds\")\n\narima <- readRDS(file = \"RDS/arima.rds\") # arima\narima2 <- readRDS(file = \"RDS/arima2.rds\") # arima\n\npaged_table(arima)\n\n\n\n  \n\n\npaged_table(arima2)\n\n\n\n  \n\n\n\n\narima_tsbl  = as_tsibble(arima)\narima_tsbl2  = as_tsibble(arima2)\n\nhead(arima_tsbl)\n\n# A tsibble: 6 x 4 [1M]\n   year   mth peak_system_demand_mw     Date\n  <dbl> <dbl>                 <dbl>    <mth>\n1  2005     1                  5083 2005 Jan\n2  2005     2                  5285 2005 Feb\n3  2005     3                  5333 2005 Mar\n4  2005     4                  5408 2005 Apr\n5  2005     5                  5385 2005 May\n6  2005     6                  5298 2005 Jun\n\nhead(arima_tsbl2)\n\n# A tsibble: 6 x 2 [1M]\n      Date   sum\n     <mth> <dbl>\n1 2005 Jan 1342.\n2 2005 Feb 1311.\n3 2005 Mar 1438.\n4 2005 Apr 1600.\n5 2005 May 1604 \n6 2005 Jun 1680.\n\n\n\narima_tsbl  = as_tsibble(arima)\nfull_arima = arima_tsbl %>%\n  fill_gaps() %>% \n  tidyr::fill(peak_system_demand_mw, .direction = \"down\")\n\narima_tsbl2  = as_tsibble(arima2)\nfull_arima2 = arima_tsbl2 %>%\n  fill_gaps() %>% \n  tidyr::fill(sum, .direction = \"down\")\n\nsaveRDS(arima_tsbl, file = \"RDS/arima_tsbl.rds\")\nsaveRDS(arima_tsbl2, file = \"RDS/arima_tsbl2.rds\")\nsaveRDS(full_arima, file = \"RDS/full_arima.rds\")\nsaveRDS(full_arima2, file = \"RDS/full_arima2.rds\")\n\nhead(full_arima)\n\n# A tsibble: 6 x 4 [1M]\n   year   mth peak_system_demand_mw     Date\n  <dbl> <dbl>                 <dbl>    <mth>\n1  2005     1                  5083 2005 Jan\n2  2005     2                  5285 2005 Feb\n3  2005     3                  5333 2005 Mar\n4  2005     4                  5408 2005 Apr\n5  2005     5                  5385 2005 May\n6  2005     6                  5298 2005 Jun\n\nhead(full_arima2)\n\n# A tsibble: 6 x 2 [1M]\n      Date   sum\n     <mth> <dbl>\n1 2005 Jan 1342.\n2 2005 Feb 1311.\n3 2005 Mar 1438.\n4 2005 Apr 1600.\n5 2005 May 1604 \n6 2005 Jun 1680.\n\n\n\narima <- town %>% \n  group_by(date) %>% \n  summarise(sum = sum(kwh_per_acc)) %>% \n  mutate(month = month(date)) %>% \n  mutate(year = year(date))\n\narima$date <- yearmonth(as.yearmon(paste(arima$year, arima$month), \"%Y %m\"))\n\narima_tsbl  = as_tsibble(arima)\nsaveRDS(arima_tsbl, file = \"RDS/arima_tsbl.rds\")\n\n\nfull_arima = arima_tsbl %>%\n  fill_gaps() %>% \n  tidyr::fill(sum, .direction = \"down\")\n\nhead(arima_tsbl)\n\n# A tsibble: 6 x 4 [1M]\n      date     sum month  year\n     <mth>   <dbl> <int> <int>\n1 2005 Jan  90843.     1  2005\n2 2005 Feb  90238.     2  2005\n3 2005 Mar  96156.     3  2005\n4 2005 Apr 108260.     4  2005\n5 2005 May 106869.     5  2005\n6 2005 Jun 109848.     6  2005\n\nhead(full_arima)\n\n# A tsibble: 6 x 4 [1M]\n      date     sum month  year\n     <mth>   <dbl> <int> <int>\n1 2005 Jan  90843.     1  2005\n2 2005 Feb  90238.     2  2005\n3 2005 Mar  96156.     3  2005\n4 2005 Apr 108260.     4  2005\n5 2005 May 106869.     5  2005\n6 2005 Jun 109848.     6  2005\n\nsaveRDS(full_arima, file = \"RDS/full_arima.rds\")\n\n\nlibrary(timetk)\narima_tsbl$date <- as.Date(arima_tsbl$date)\n\narima_tsbl %>%\n  plot_time_series(date, sum, .facet_ncol = 2,.interactive = TRUE)\n\n\n\n\n\n\nfull_arima_stl=full_arima %>% \n  summarise(sum = sum(sum)) %>% \n  model(STL(sum ~ season(window = 5))) %>% \n  components()\n\nfull_arima_stl2=full_arima2 %>% \n  summarise(sum = sum(sum)) %>% \n  model(STL(sum ~ season(window = 5))) %>% \n  components()\n\nsaveRDS(full_arima_stl, file = \"RDS/full_arima_stl.rds\")\n\nhead(full_arima_stl)\n\n# A dable: 6 x 7 [1M]\n# Key:     .model [1]\n# :        sum = trend + season_year + remainder\n  .model                            date     sum   trend seaso…¹ remai…² seaso…³\n  <chr>                            <mth>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 STL(sum ~ season(window = 5)) 2005 Jan  90843. 100641.  -8242.  -1556.  99085.\n2 STL(sum ~ season(window = 5)) 2005 Feb  90238. 100720. -11194.    712. 101432.\n3 STL(sum ~ season(window = 5)) 2005 Mar  96156. 100799.  -6392.   1749. 102549.\n4 STL(sum ~ season(window = 5)) 2005 Apr 108260. 100879.   4338.   3043. 103922.\n5 STL(sum ~ season(window = 5)) 2005 May 106869. 100973.   6709.   -813. 100160.\n6 STL(sum ~ season(window = 5)) 2005 Jun 109848. 101067.   7785.    995. 102062.\n# … with abbreviated variable names ¹​season_year, ²​remainder, ³​season_adjust\n\nhead(full_arima_stl2)\n\n# A dable: 6 x 7 [1M]\n# Key:     .model [1]\n# :        sum = trend + season_year + remainder\n  .model                            Date   sum trend season_year remai…¹ seaso…²\n  <chr>                            <mth> <dbl> <dbl>       <dbl>   <dbl>   <dbl>\n1 STL(sum ~ season(window = 5)) 2005 Jan 1342. 1529.      -144.   -42.6    1487.\n2 STL(sum ~ season(window = 5)) 2005 Feb 1311. 1528.      -188.   -29.3    1499.\n3 STL(sum ~ season(window = 5)) 2005 Mar 1438. 1527.      -125.    35.3    1563.\n4 STL(sum ~ season(window = 5)) 2005 Apr 1600. 1527.        25.6   47.6    1574.\n5 STL(sum ~ season(window = 5)) 2005 May 1604  1526.        71.2    6.97   1533.\n6 STL(sum ~ season(window = 5)) 2005 Jun 1680. 1525.       125.    30.0    1555.\n# … with abbreviated variable names ¹​remainder, ²​season_adjust\n\n\n\nfull_arima_stl %>% \n  summarise(sum = sum(sum)) %>%\n  model(STL(sum ~ season(window = 5))) %>% \n  components() %>%\n  autoplot()\n\n\n\n\n\narima_tsbl  = as_tsibble(arima)\nfull_arima = arima_tsbl %>%\n  # filter(year==2017) %>% \n  fill_gaps() %>% \n  tidyr::fill(sum, .direction = \"down\")\n\nfull_arima %>%\n  gg_tsdisplay(difference(sum), plot_type='partial')\n\n\n\n\n\nlibrary(forecast)\narima_ts <- ts(data=arima$sum, start = c(2005,1), end = c(2022, 6), frequency=12)\nplot.ts(arima_ts, plot.type=('single'))    \n\n\n\narima_arima <- auto.arima(arima_ts)\n\nsaveRDS(arima_arima, file = \"RDS/arima_arima.rds\")\nsaveRDS(arima_ts, file = \"RDS/arima_ts.rds\")\n\n\narima_ts %>%\n  auto.arima() %>%\n  forecast(h=20) %>%\n  autoplot()\n\n\n\n\n\narima_ts %>%\n  stlm(modelfunction=ar) %>%\n  forecast(h=36) %>%\n  autoplot()\n\n\n\n\n\narima_ts %>%\n  tbats() %>%\n  forecast() %>%\n  autoplot()\n\n\n\n\n\nplot(forecast(arima_arima, h = 48))"
  }
]