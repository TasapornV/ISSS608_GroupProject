---
title: "Sandbox"
author: "G9"
format: 
  html:
    mainfont: system-ui
    fontsize: medium
    code-block-border-left: "#63B9A0"
    code-overflow: wrap
    highlight-style: solarized
    page-layout: full
    number-sections: true
    title-block-banner: true
    fig-align: center
    reader-mode: true
---

## Install and launching R packages

```{r init, results='hide', message=FALSE}
packages = c('tidyverse', 'ggstatsplot', 'psych', 'lubridate', 'ggrepel', 'plotly', "tidyr", "readr")
for(p in packages){
  if(!require(p,character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## Read data and compress in RDS file

This section of code is used to compress the file so that it will not load too slowly when it is uploaded to the website. I've already built the RDS files in the RDS folder, so you don't need to run this script.

```{r}
dwelling <- T3.4 %>%
  filter(year %in% c(2005:2022)) %>%
  filter(month %in% c(1:12)) %>%
  filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
                              '5-room and Executive',
                              'Private Apartments and Condominiums',
                              'Landed Properties', 'Others')) %>%
  mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
  mutate(monthyear = format(as.Date(date), "%b %Y"))

dwelling$class <- case_when(
  dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
                                'Landed Properties', 'Others') ~ "Private",
  dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
                                '5-room and Executive') ~ "Public")

saveRDS(dwelling, file = "RDS/dwelling.rds")
```

```{r}
# wrangling data
town <- subset(T3.5, Description != 'Overall' & Description !='Central Region' & 
                 Description !='East Region' & Description !='North East Region' &
                 Description !='North Region' & Description !='West Region' &
                 kwh_per_acc != 's' & dwelling_type != 'Private Housing' &
                 dwelling_type != 'Public Housing' & month != 'Annual') %>%
  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
  mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd"))

town$type <- case_when(
  town$dwelling_type %in% c('Private Apartments and Condominiums',
                            'Landed Properties', 'Others') ~ "Private",
  town$dwelling_type %in% c('1-room / 2-room','3-room','4-room',
                            '5-room and Executive') ~ "Public")
saveRDS(town, file = "RDS/town.rds")
```

```{r read data, warning=FALSE, message=FALSE}
library(readr)
T2.3 <- read_csv("data/T2-3.csv")
saveRDS(T2.3, file = "RDS/T2-3.rds")

#T2.6 <- read_csv("data/T2-6.csv")
#saveRDS(T2.6, file = "RDS/T2-6.rds")

T3.4 <- read_csv("data/T3-4.csv")
saveRDS(T3.4, file = "RDS/T3-4.rds")

T3.5 <- read_csv("data/T3-5.csv")
saveRDS(T3.5, file = "RDS/T3-5.rds")

T3.6 <- read_csv("data/T3-6.csv")
saveRDS(T3.6, file = "RDS/T3-6.rds")

T3.7 <- read_csv("data/T3-7.csv")
saveRDS(T3.7, file = "RDS/T3-7.rds")

T3.8 <- read_csv("data/T3-8.csv")
saveRDS(T3.8, file = "RDS/T3-8.rds")

T3.9 <- read_csv("data/T3-9.csv")
saveRDS(T3.9, file = "RDS/T3-9.rds")

# T5.1 <- read_csv("data/T5-1.csv")
# saveRDS(T5.1, file = "RDS/T5-1.rds")
# 
# T5.2 <- read_csv("data/T5-2.csv")
# saveRDS(T5.2, file = "RDS/T5-2.rds")

#T5.3 <- read_csv("data/T5-3.csv")
#saveRDS(T5.3, file = "RDS/T5-3.rds")

# T5.4 <- read_csv("data/T5-4.csv")
# saveRDS(T5.4, file = "RDS/T5-4.rds")
# 
# T5.5 <- read_csv("data/T5-5.csv")
# saveRDS(T5.4, file = "RDS/T5-5.rds")
```

### Data table

T2.3 : Peak System Demand

```{r T2.3, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T2.3, 5))
```

T2.6 : Market Share of Electricity Generation

```{r T2.6, echo=FALSE}
#| fig-width: 10
# knitr::kable(head(T2.6, 5))
```

T3.4 : Total Household Electricity Consumption by Dwelling Type

```{r T3.4, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.4, 5))
```

T3.5 : Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type

```{r T3.5, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.5, 5))
```

T3.6 : Market Share for Natural Gas Retail

```{r T3.6, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.6, 5))
```

T3.7 : Natural Gas Consumption by Sub-Sector

```{r T3.7, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.7, 5))
```

T3.8 : Total Household Town Gas Consumption by Dwelling Type

```{r T3.8, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.8, 5))
```

T3.9 : Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type

```{r T3.9, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T3.9, 5))
```

**T5.1 : Electricity and Gas Tariffs**

```{r T5.1, echo=FALSE}
#| fig-width: 10
# knitr::kable(head(T5.1, 5))
```

**T5.2 : Monthly Electricity Tariffs (Low Tension Tariffs)**

```{r T5.2, echo=FALSE}
#| fig-width: 10
# knitr::kable(head(T5.2, 5))
```

**T5.3 : Annual Electricity Tariffs by Components (Low Tension Tariffs)**

```{r T5.3, echo=FALSE}
#| fig-width: 10
# knitr::kable(head(T5.3, 5))
```

**T5.4 : Average Monthly Uniform Singapore Energy Prices (USEP)**

```{r T5.4, echo=FALSE}
#| fig-width: 10
# knitr::kable(head(T5.4, 5))
```

**T5.5 : Monthly Town Gas Tariffs**

```{r T5.5, echo=FALSE}
#| fig-width: 10
knitr::kable(head(T5.5, 5))
```

**Code for load data**

```{r}
## Read compressed data file
T2.3 <- readRDS(file = "RDS/T2-3.rds") # Peak System Demand
#T2.6 <- readRDS(file = "RDS/T2-6.rds") # Market Share of Electricity Generation
T3.4 <- readRDS(file = "RDS/T3-4.rds") # Total Household Electricity Consumption by Dwelling Type
T3.5 <- readRDS(file = "RDS/T3-5.rds") # Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type
#T3.6 <- readRDS(file = "RDS/T3-6.rds") # Market Share for Natural Gas Retail
#T3.7 <- readRDS(file = "RDS/T3-7.rds") # Natural Gas Consumption by Sub-Sector
#T3.8 <- readRDS(file = "RDS/T3-8.rds") # Total Household Town Gas Consumption by Dwelling Type
#T3.9 <- readRDS(file = "RDS/T3-9.rds") # Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type
#T5.1 <- readRDS(file = "RDS/T5-1.rds") # Electricity and Gas Tariffs
#T5.2 <- readRDS(file = "RDS/T5-2.rds") # Monthly Electricity Tariffs (Low Tension Tariffs)
#T5.3 <- readRDS(file = "RDS/T5-3.rds") # Annual Electricity Tariffs by Components (Low Tension Tariffs)
#T5.4 <- readRDS(file = "RDS/T5-4.rds") # Average Monthly Uniform Singapore Energy Prices (USEP)
#T5.5 <- readRDS(file = "RDS/T5-5.rds") # Monthly Town Gas Tariffs
```

## Shiny

### Skeleton

```{r skeleton, warning = FALSE, message=FALSE}
# call library used
library(shiny)
library(shinythemes)

## Set up parameter


ui = fluidPage(
  theme = shinytheme("slate"),
  headerPanel(title = "Singapore Energy Consumption"),
  
  navlistPanel(
    widths = c(3, 9),
     
    tabPanel("OVERVIEW",tabName = "overview",icon = icon("chalkboard-user"),
             navbarPage("OVERVIEW", 
                        tabPanel("Introduction"),
                        tabPanel("Boxplot"),
                        tabPanel("Geofacet"),
                        tabPanel("Lineplot"),
                        tabPanel("Barchart")
             )
    ),
      
    # ========================== CLUSTERING ========================== #
    
    tabPanel("CLUSTERING", tabName = "clustering", icon = icon("circle-nodes"),
             navbarPage("CLUSTERING", 
                        tabPanel("Hierachical Clustering"),
                        tabPanel("DTW"),
                        tabPanel("Time Series Clustering")
             )
    ),
    
    # ========================== INFERENTIAL ========================== #     
    
    tabPanel("INFERENTIAL STATISTICS", tabName = "inferential", icon = icon("magnifying-glass-chart"),
             navbarPage("INFERENTIAL STATISTICS", 
                        tabPanel("ANOVA"),
                        tabPanel("Correlation Analysis")
             )
    ),
    
    # ========================== TIME SERIES ========================== #     
    
    tabPanel("TIME SERIES FORECASTING", tabName = "time_series", icon = icon("chart-line"),
             navbarPage("TIME SERIES FORECASTING",
                        tabPanel("Trend Prediction"),
                        tabPanel("Slope Graph")
             )
    ),
    
    # =============================== DATA =============================== #     
    
    tabPanel("DATA", tabName = "data", icon = icon("table"),
             navbarPage("DATA" )),
    # =============================== ABOUT =============================== #    
    
    tabPanel("ABOUT", tabName = "about", icon = icon("info")),
    # ============================== CO.MMON USER INPUT =============================== #    
    tabPanel(wellPanel(
      sliderInput("slider_time", "Select date range",min = as.Date("2021-02-24"), 
                  max = as.Date("2021-04-24"), 
                  value =  c(as.Date("2021-02-24"),as.Date("2021-03-03") )),
      
      dateRangeInput("daterange", "Input date range", 
                     start = as.Date("2021-02-24"),end = as.Date("2021-03-03") )
    ))
  )
)

server = function(input, output, session) {
  
}

shinyApp(ui , server )
```

### Data tab : data table page

```{r DataTable, warning=FALSE, message=FALSE}
library(shiny)
library(shinythemes)

## Set up parameter
tables <- c("Peak System Demand" = "T2.3",
            "Market Share of Electricity Generation" = "T2.6",
            "Total Household Electricity Consumption by Dwelling Type" = "T3.4",
            "Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type" = "T3.5",
            "Market Share for Natural Gas Retail" = "T3.6",
            "Natural Gas Consumption by Sub-Sector" = "T3.7",
            "Total Household Town Gas Consumption by Dwelling Type" = "T3.8",
            "Average Monthly Household Town Gas Consumption by Planning Area & Dwelling Type" = "T3.9",
            "Electricity and Gas Tariffs" = "T5.1",
            "Monthly Electricity Tariffs (Low Tension Tariffs)" = "T5.2",
            "Annual Electricity Tariffs by Components (Low Tension Tariffs)" = "T5.3",
            "Average Monthly Uniform Singapore Energy Prices (USEP)" = "T5.4",
            "Monthly Town Gas Tariffs" = "T5.5")

ui = fluidPage(
  theme = shinytheme("slate"),
  headerPanel(title = "Singapore Energy Consumption"),
  
  navlistPanel(
    widths = c(3, 9),
    
    # ========================== OVERVIEW ========================== #      
    tabPanel("OVERVIEW",tabName = "overview",icon = icon("chalkboard-user")),
    
    # ========================== CLUSTERING ========================== #
    
    tabPanel("CLUSTERING", tabName = "clustering", icon = icon("circle-nodes")),
    
    # ========================== INFERENTIAL ========================== #     
    
    tabPanel("INFERENTIAL STATISTICS", tabName = "inferential", icon = icon("magnifying-glass-chart")),
    
    # ========================== TIME SERIES ========================== #     
    
    tabPanel("TIME SERIES FORECASTING", tabName = "time_series", icon = icon("chart-line")),
    
    # =============================== DATA =============================== #     
    
    tabPanel("DATA", tabName = "data", icon = icon("table"),
             navbarPage("DATA",
                        tabPanel("data table",
                                 fluidPage(
                                   fluidRow(
                                     column(12, wellPanel(
                                       radioButtons("SelectTable",
                                                    label = "Select Data",
                                                    choices = tables,
                                                    selected = "Electricity")
                                     ) ),
                                     column(12, dataTableOutput("table"))
                                   )
                                 ))
             )
    ),
    
    # ******************************* END DATA ******************************* #    
    
    # =============================== ABOUT =============================== #    
    
    tabPanel("ABOUT", tabName = "about", icon = icon("info")),
    
    # ****************************** END ABOUT ****************************** #    
    tabPanel(wellPanel(
      sliderInput("slider_time", "Select date range",min = as.Date("2021-02-24"), 
                  max = as.Date("2021-04-24"), 
                  value =  c(as.Date("2021-02-24"),as.Date("2021-03-03") )),
      
      dateRangeInput("daterange", "Input date range", 
                     start = as.Date("2021-02-24"),end = as.Date("2021-03-03") )
    ))
  )
)

server = function(input, output, session) {
  
  observeEvent((input$SelectTable),{
                if(input$SelectTable == "T2.3") {tabletext <- T2.3}
               if(input$SelectTable == "T2.6")  {tabletext <- T2.6}
               if(input$SelectTable == "T3.4")  {tabletext <- T3.4}
               if(input$SelectTable == "T3.5")  {tabletext <- T3.5}
               if(input$SelectTable == "T3.6")  {tabletext <- T3.6}
               if(input$SelectTable == "T3.7")  {tabletext <- T3.7}
               if(input$SelectTable == "T3.8")  {tabletext <- T3.8}
               if(input$SelectTable == "T3.9")  {tabletext <- T3.9}
               if(input$SelectTable == "T5.1")  {tabletext <- T5.1}
               if(input$SelectTable == "T5.2")  {tabletext <- T5.2}
               if(input$SelectTable == "T5.3")  {tabletext <- T5.3}
               if(input$SelectTable == "T5.4")  {tabletext <- T5.4}
               if(input$SelectTable == "T5.5")  {tabletext <- T5.5}
               output$table <- renderDataTable(tabletext)
               }
  )
}

shinyApp(ui = ui, server = server)
```

### Overview tab : geofacet

```{r geofacet, warning=FALSE, message=FALSE}
library(shiny)
library(shinythemes)
library(geofacet)

# Import data 
geofacet <- T3.5
geofacet$kwh_per_acc <- as.numeric(geofacet$kwh_per_acc)

# Import the area grid data.
area_grid <- read_csv("data/areagrid.csv")

geofacet <- geofacet %>%
  group_by(year, dwelling_type, Description ) %>%
  summarise(avgprice = mean(kwh_per_acc, na.rm = TRUE),
            medprice = median(kwh_per_acc, na.rm = TRUE))%>%
  ungroup()

# merge table with town name
geofacet_gas_consump <- inner_join(geofacet, area_grid,
                      by = c("Description" = "name"))

common_grid <- area_grid[area_grid$name %in% unique(geofacet$Description),]
ggplot(geofacet_gas_consump, aes(x = year, y = avgprice)) +
  geom_line(aes(color = as.factor(dwelling_type))) +
  # scale_x_date(date_labels = "%b") +
  facet_geo(~Description, grid = common_grid) +
  # labs(title = "Singapore Resale flat price trends") +
  # scale_y_continuous(breaks = c(250000, 500000, 750000, 1000000, 1250000)) +
  theme(plot.title = element_text(size=22),
        axis.text.x = element_text(size = 10, angle = 45),
        axis.text.y = element_text(size = 10),
        strip.text = element_text(size = 10),
        legend.position = "top")
```

```{r geofacetshiny, warning = FALSE, message=FALSE}

# call library used
library(shiny)
library(shinythemes)
library(geofacet)
library(shinyWidgets)

# Import data 
geofacet <- T3.5
geofacet$kwh_per_acc <- as.numeric(geofacet$kwh_per_acc)

# Import the area grid data.
area_grid <- read_csv("data/areagrid.csv")

ui = fluidPage(
  theme = shinytheme("slate"),
  headerPanel(title = "Singapore Energy Consumption"),
  
  navlistPanel(
    widths = c(3, 9),
    tabPanel("OVERVIEW",tabName = "overview",icon = icon("chalkboard-user"),
             navbarPage("OVERVIEW", 
                        tabPanel("Introduction"),
                        tabPanel("Boxplot"),
                        tabPanel("Geofacet",
                                 fluidPage(
                                   fluidRow(
                                     column(12,plotOutput("geo", height = 800))
                                   )
                                 )
                        ),
                        tabPanel("Lineplot"),
                        tabPanel("Barchart")
             )
    ),
    
    # ========================== CLUSTERING ========================== #
    
    tabPanel("CLUSTERING", tabName = "clustering", icon = icon("circle-nodes"),
             navbarPage("CLUSTERING", 
                        tabPanel("Hierachical Clustering"),
                        tabPanel("DTW"),
                        tabPanel("Time Series Clustering")
             )
    ),
    
    # ========================== INFERENTIAL ========================== #     
    
    tabPanel("INFERENTIAL STATISTICS", tabName = "inferential", icon = icon("magnifying-glass-chart"),
             navbarPage("INFERENTIAL STATISTICS", 
                        tabPanel("ANOVA"),
                        tabPanel("Correlation Analysis")
             )
    ),
    
    # ========================== TIME SERIES ========================== #     
    
    tabPanel("TIME SERIES FORECASTING", tabName = "time_series", icon = icon("chart-line"),
             navbarPage("TIME SERIES FORECASTING",
                        tabPanel("Trend Prediction"),
                        tabPanel("Slope Graph")
             )
    ),
    
    # =============================== DATA =============================== #     
    
    tabPanel("DATA", tabName = "data", icon = icon("table"),
             navbarPage("DATA" )),
    # =============================== ABOUT =============================== #    
    
    tabPanel("ABOUT", tabName = "about", icon = icon("info")),
    # ============================== CO.MMON USER INPUT =============================== #    
    tabPanel(wellPanel(
      sliderInput("slider_time", "Select date range",min = as.Date("2021-02-24"), 
                  max = as.Date("2021-04-24"), 
                  value =  c(as.Date("2021-02-24"),as.Date("2021-03-03") )),
      
      dateRangeInput("daterange", "Input date range", 
                     start = as.Date("2021-02-24"),end = as.Date("2021-03-03") )
    ))
  )
)

server = function(input, output, session) {
  
  output$geo <- renderPlot ({
    geofacet <- geofacet %>%
      group_by(year, dwelling_type, Description ) %>%
      summarise(avgprice = mean(kwh_per_acc, na.rm = TRUE),
                medprice = median(kwh_per_acc, na.rm = TRUE))%>%
      ungroup()
    
    # merge table with town name
    geofacet_gas_consump <- inner_join(geofacet, area_grid,
                                       by = c("Description" = "name"))
    
    common_grid <- area_grid[area_grid$name %in% unique(geofacet$Description),]
    ggplot(geofacet_gas_consump, aes(x = year, y = avgprice)) +
      geom_line(aes(color = as.factor(dwelling_type))) +
      # scale_x_date(date_labels = "%b") +
      facet_geo(~Description, grid = common_grid) +
      labs(title = "Average Monthly Household Electricity Consumption by Planning Area & Dwelling Type") +
      # scale_y_continuous(breaks = c(250000, 500000, 750000, 1000000, 1250000)) +
      theme(plot.title = element_text(size=22),
            axis.text.x = element_text(size = 10, angle = 45),
            axis.text.y = element_text(size = 10),
            strip.text = element_text(size = 10),
            legend.position = "right")
  })
}

shinyApp(ui , server )
```

### Time Series Forecasting

```{r timeseries_library}
packages = c('tidyverse','tidyquant','tsibbledata','tsibble','feasts'
             ,'stats','lubridate','data.table','rmarkdown','knitr')
for (p in packages) {
  if(!require(p,character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

```{r timeseries_data, warning=FALSE, message=FALSE}
arima <- T2.3
arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
arima2 <- T3.4
arima2$Date <- yearmonth(as.yearmon(paste(arima2$year, arima2$month), "%Y %m"))
arima3 <- T3.5 
arima3$Date <- yearmonth(as.yearmon(paste(arima3$year, arima3$month), "%Y %m"))

paged_table(arima)
paged_table(arima2)
paged_table(arima3)
```

```{r}
arima_tsbl  = as_tsibble(arima)

head(arima_tsbl)

```

```{r}
arima_tsbl  = as_tsibble(arima)
full_arima = arima_tsbl %>%
  fill_gaps() %>% 
  tidyr::fill(peak_system_demand_mw, .direction = "down")

head(full_arima)
```

```{r}
full_arima_mth_agg = full_arima %>%
  # index_by(Date = ~ Date(.)) %>% 
  summarise(
    avg_demand = mean(peak_system_demand_mw, na.rm = TRUE)
  )

head(full_arima_mth_agg)
```

Seasonal plot

```{r}
full_arima %>%
   gg_season(peak_system_demand_mw)+
  labs(title = "",
       subtitle = "",
       y = "peak_system_demand_mw")
```

```{r}
full_arima_2019 = full_arima %>%
  filter(year == 2019) %>%
  mutate(quarter= case_when(
      mth >= 1 & mth <= 3 ~ 'Q1'
      , mth >= 4 & mth <= 6 ~ 'Q2'
      , mth >= 7 & mth <= 9 ~ 'Q3'
      , mth >= 10 & mth <= 12 ~ 'Q4')) %>%
    select(year, mth, peak_system_demand_mw, Date) 

full_arima_2019 %>%
   gg_lag(peak_system_demand_mw, geom = "point")+
   labs(title = "Lag plot of the time plot of the humidity level of hourly meterological data",
       y = "Humidity level")
```

```{r}
full_arima_acf=full_arima_2019 %>% ACF(peak_system_demand_mw, lag_max = 36)

head(full_arima_acf)
```

```{r}
full_arima_2019 %>%
  ACF(peak_system_demand_mw) %>%
  autoplot() + labs(title="")
```

```{r}
full_arima_stl=full_arima %>% 
  summarise(peak_system_demand_mw = sum(peak_system_demand_mw)) %>% 
  model(STL(peak_system_demand_mw ~ season(window = 5))) %>% 
  components()

head(full_arima_stl)
```

```{r}
full_arima_stl %>% 
  summarise(peak_system_demand_mw = sum(peak_system_demand_mw)) %>% 
  model(STL(peak_system_demand_mw ~ season(window = 5))) %>% 
  components() %>%
  autoplot()+
  labs(title = "",
       y = "peak_system_demand_mw")
```

### Timetk

```{r}
packages = c('dplyr','tidyquant','tidyverse','tsibble','feasts','forecast','fable'
             ,'tsibbletalk','tidymodels','earth'
             ,'stats','lubridate','data.table','ggplot2','plotly'
             ,'rmarkdown','knitr','devtools','tseries')
for (p in packages) {
  if(!require(p,character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

```{r}
arima %>%
  ggplot(aes(x = Date, y = peak_system_demand_mw)) +
  geom_line(size = 0.5)+
  labs(title = "") +
  theme(text = element_text(color = "#444444", family = 'Helvetica Neue')
        ,plot.title = element_text(size = 35, color = '#333333')
        ,axis.title = element_text(size = 14, color = '#333333')
        ,axis.title.y = element_text(angle = 0, vjust = .5)
        ) +
    theme_tq() + 
    scale_color_tq()
```

```{r}
arima_ts <- ts(data=arima$peak_system_demand_mw, start = c(2005,1), end = c(2022, 6), frequency=12)
plot.ts(arima_ts, plot.type=('single'))                   
```

```{r}
arima_ds = diff(arima_ts, differences = 2)
ggplotly(plot(arima_ds))
```

```{r}
arima_arima = auto.arima(arima_ts)
arima_arima
plot(forecast(arima_ts))
```

```{r}
 arima <- T2.3
  arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
  arima_ts <- ts(data=arima$peak_system_demand_mw)
  arima_arima = auto.arima(arima_ts, d =1, D =1, allowdrift = FALSE)

  # plot(forecast(arima_ts))

```

```{r, warning = FALSE, message=FALSE}
arima_tsbl  = as_tsibble(arima)
full_arima = arima_tsbl %>%
  # filter(year==2017) %>% 
  fill_gaps() %>% 
  tidyr::fill(peak_system_demand_mw, .direction = "down")

full_arima %>%
  gg_tsdisplay(difference(peak_system_demand_mw), plot_type='partial')
```

```{r, warning=FALSE, message=FALSE}
consumption <- read_csv("data/T3-5.csv")
consumption <- consumption %>% 
  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>% 
  mutate(year = as.character(year))

energycost <- read_csv("data/T5-3.csv")
energycost <- energycost %>% 
  mutate(year = as.character(year))

#merge
a <- consumption %>% 
  select("year", "kwh_per_acc") %>% 
  group_by(year) %>%
  na.omit() %>%
  summarize(kwh_per_acc=mean(kwh_per_acc))
#b <- b %>% 
#  data.frame(energycost,a) %>% 
#  select("year", "kwh_per_acc", "energy_costs_cent_per_kwh")

consumption %>% 
  group_by(year) %>%
  # filter(year == "2022") %>% 
  ggplot(mapping = aes(x = year, y = kwh_per_acc)) +
  # Make grouped boxplot
  geom_boxplot(aes(fill = as.factor(Region)), color = "grey") +
  theme_minimal() +
  theme(legend.position = "top") +
  scale_fill_viridis_d(option = "C") +
  labs(title = "Average consumption per year by Region", y="kwh per acc", fill = "Region")
```

```{r ANOVA}
set.seed(1234)

consumption <- T3.5
consumption <- consumption %>% 
  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>% 
  mutate(year = as.character(year))

ggbetweenstats(
  data = consumption,
  x = Region,
  y = kwh_per_acc,
  # type = "np",
  messages = FALSE
)
```

```{r box plot, message=FALSE, warning=FALSE}
consumption %>%
  mutate(class = fct_reorder(Description, kwh_per_acc, .fun='mean')) %>%
  ggplot( aes(x=reorder(Description, kwh_per_acc), y=kwh_per_acc)) +
  geom_boxplot() +
  stat_summary(fun.y=mean, geom="point", color="red") +
  theme(legend.position="none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggtitle("Boxplot of consumption per planning area")

summary(aov(kwh_per_acc ~ dwelling_type, data = consumption))
```

```{r}
library(RColorBrewer)
library(tidyverse)
library(lubridate)
library(geofacet)
library(treemap)
library(ggstatsplot)
library(ggridges)
```

# Final: Clustering - data preparation

```{r}
# Filter the required data for clustering

# remove month = "Annual"
# remove dewlling_type/description = Overall
# year 2018 and onwards due to missing data
# exclude "%region" in description
# Exclude Pioneer as data is incomplete

clus_data <- T3.5 %>% 
  filter(month != "Annual" & 
           year > 2017 & 
           dwelling_type != "Overall" &
           !str_detect(Description,"Region|Pioneer|Overall"))

# transform dataset
# convert kwh into numbers
clus_data$kwh_per_acc <- as.numeric(clus_data$kwh_per_acc)
# join month and year into a date
clus_data$date <- parse_date_time(paste(clus_data$year, clus_data$month), orders=c("%Y %m")) 

# drop month and year column
clus_data <- subset(clus_data, select=-c(month, year, Region)) %>%
  arrange(date)

# pivot wider
clus <- clus_data %>%
  pivot_wider(names_from=date, values_from=kwh_per_acc) 

# omit na
clus <- na.omit(clus)
clus <- clus %>% relocate(Description, .before = dwelling_type)

# clus_data
# clus
```

# Final: Clustering using dendextend & heatmap - Aggregated demand at description level

```{r}
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)
# parameter 5: scale / normalize / percentize (the code for this part is different)

# Remove dwelling type
clus_group1 <- clus[,-c(2)] %>%
  group_by(Description) %>%
  summarise_each(list(sum))

# making "Description" the row name (index)
row.names(clus_group1) <- clus_group1$Description

# Making it into a matrix
clus_matrix1 <- data.matrix(clus_group1)

# plot
heatmaply(clus_matrix1[,-c(1)],
          scale = "column",
          dist_method = "euclidean",
          hclust_method = "average",
          Colv=NA,
          seriate = "none",
          k_row = 3,
          margins = c(NA,200,50,NA),
          colors = viridis(
            n= 256, alpha=1, 
            begin=0, end=1,
            option="viridis"),
          fontsize_row = 5,
          fontsize_col = 5,
          main="Hierarchical Clustering",
          ylab = "Towns",
          xlab = "Time")
```

# Final: using dendextend to determine the recommended clustering method

```{r}

# parameter: method 
# user will need to input the distance calculated method here to determine which clustering method is optimal

library(dendextend)
clustering <- dist(normalize(clus_group1,-c(1)), method="euclidean")
dend_expend(clustering)[[3]]
# 
# library(dendextend)
# clustering <- dist(as.numeric(normalize(clus_group1,-c(1))), method="euclidean")
# dend_expend(clustering)[[3]]

```

```{r}

```

# Final: using find_k() to determine the optimal number of clusters

```{r}
# once user have gotten the clustering method from above, they need to input that to find the optimal number of k
clust2 <- hclust(clustering, method = "mcquitty")
num_k <- find_k(clust2)
plot(num_k)
```

# Final: Adding the clusters to dataset for Choropleth map

```{r}
## Add clusters to dataframe
num_clus <- cutree(clust2, k=3)
clus_hc <- cbind(clus_group1, cluster = as.factor(num_clus))
```

```{r}
library(sf)
# reading the map file
mpsz <- st_read(dsn = 'master-plan-2014-subzone-boundary-web-shp',
                layer = 'MP14_SUBZONE_WEB_PL',
                crs = 3414) 

singapore <- st_transform(mpsz, 4326)
```

```{r}
library(tmap)
# change Description to upper case
clus_hc$Description <- toupper(clus_hc$Description)

# Preparing the choropleth map
mpsz_clus <- left_join(singapore, clus_hc, by = c("PLN_AREA_N" = "Description"))
tmap_mode("view")
tm_shape(mpsz_clus)+
  tmap_options(check.and.fix = TRUE)+
  tm_fill("cluster", id=paste("PLN_AREA_N"),
          style = "pretty",
          palette = "Blues") +
  tm_borders(alpha = 0.7)
```

# Final: DTW (time series clustering)

```{r}
library(dtwclust)
library(tibble)
library(ggdendro)

# Clustering Method (type) ("partitional", "hierarchical", "tadpole", "fuzzy".) - fixed at hierarchical, otherwise need to change the quote because some parameters apply only to certain methods
# parameter 1: Number of cluster (k)
# parameter 2: Distance function (distance) (dtw_basic, dtw, dtw2, lbk, lbi, sbd, gak, sdtw) - full form can be found https://www.rdocumentation.org/packages/dtwclust/versions/5.5.12/topics/tsclust
# parameter 3: hierarchical clustering method ("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median" or "centroid" .)



cluster_dtw <- tsclust(clus_matrix1[,-c(1)],
                       type = "h", 
                       k=2,
                       distance="dtw",
                       control = hierarchical_control(method = "ward.D"),
                       preproc = NULL,
                       args=tsclust_args(dist = list(window.size = 5L)))

hclus_dtw <- cutree(cluster_dtw, k=4) %>%
  as.data.frame(.) %>%
  rename(.,cluster_group = .) %>%
  rownames_to_column("type_col")

# hcdata <- dendro_data(cluster_dtw)
# names_order <- hcdata$labels$label
```

```{r}
library(ggplot2)
library(ggiraph)
library(timetk)

# add the cluster number
dtw_cluster <- clus_group1 %>%
  left_join(hclus_dtw, by=c("Description" = "type_col")) 

# change date columns into rows
dtw_cluster_t <- dtw_cluster %>%
  mutate_at(vars(contains("202")),as.numeric) %>%
  gather(Date, value, 2:55)

# Add the word "Cluster"
dtw_cluster_t$cluster_group <- paste("Cluster", dtw_cluster_t$cluster_group)

# convert Date into date format
dtw_cluster_t$Date <- parse_date_time(dtw_cluster_t$Date, orders=c("%Y-%m-%d")) 

# plot time series by cluster

ts <- plot_time_series(.data=dtw_cluster_t,
                 .date_var=Date, 
                 .value=value,
                 .color_var=Description,
                 .facet_var=cluster_group,
                 .facet_ncol=2,
                 .facet_scales = "free_y",
                 .smooth=FALSE,
                 .line_size = 0.3,
                 .plotly_slider = TRUE,
                 .title = "Time Series Plot by cluster") 

ts <- ts %>%
  layout(hovermode="x",
         hoverlabel=list(font=list(size=7)))
ts

# how to modify the tooltip? Town is being shown twice here...
```

# Final: Click-and-appear Table

```{r}
# Click-and-appear

# When user click on 1 cluster, a table appear at the side or bottom listing all the towns in the same cluster.

dtw_cluster_t %>%
  group_by(cluster_group, Description) %>%
  summarise(sum(value)) %>%
  filter(cluster_group==1)

```

### Backup: Clustering using heatmap - Description & dwelling_type

```{r}
# parameter 1: distance method ("euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski")
# parameter 2: hclust method ("ward.D", "ward.D2","single","complete","average", "mcquitty", "median" or "centroid")
# parameter 3: number of clusters
# parameter 4: seriate (Optimal leaf ordering, Gruvaeus and Wainer, mean, none)

# with normalization
library(heatmaply)

# making town the row names
row.names(clus) <- paste(clus$Description, clus$dwelling_type)
clus_matrix <- data.matrix(clus)
heatmaply(normalize(clus_matrix[,-c(1,2)]),
          dist_method = "euclidean",
          hclust_method = "average",
          Colv=NA,
          seriate = "none",
          k_row = 3,
          margins = c(NA,200,60,NA),
          scale_fill_gradient_fun = scale_fill_gradient2(
            low = "red", 
            high = "green", 
            midpoint = 0.5, 
            limits = c(0, 1)),
          fontsize_row = 5,
          fontsize_col = 5,
          main="Hierarchical Clustering")
```

### Backup: Hierarchical Clustering - calculate distance

```{r}
# Clustering
library(cluster)

# Convert to factor
clus$Description <- factor(clus$Description)
clus$dwelling_type <- factor(clus$dwelling_type)

# calculate distance - can only use "gower" because data has categorical variable
clus_dist <- daisy(clus, metric="gower")
```

### Backup: Hierarchical Clustering - Agglomerative

```{r}
# hierarchical clustering using various methods
# (ward.D, ward.D2, single, complete, average, mcquitty, median, centroid)

# complete
hc <- hclust(clus_dist, method = "complete")

# Dendogram - k is for user to calibrate
plot(hc, label = FALSE, main = "Agglomerative, complete method")
rect.hclust(hc, k=6, border="gold3")
```

```{r}
dendro <- as.dendrogram(hc)
dendro.col <- dendro %>%
  set("branches_k_color", k = 5, value =   rainbow(5)) %>%
  set("branches_lwd", 0.6) %>%
  set("labels_colors", 
      value = c("darkslategray")) %>% 
  set("labels_cex", 0.5)
ggd1 <- as.ggdend(dendro.col)
ggplot(ggd1, theme = theme_minimal()) +
  labs(x = "Num. observations", y = "Height", title = "Dendrogram")

```

```{r}
# function to create table for clustering stats
# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive 
library(fpc)
cstats.table <- function(dist, tree, k) {
clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
                  "wb.ratio","dunn2","avg.silwidth")
clust.size <- c("cluster.size")
stats.names <- c()
row.clust <- c()
output.stats <- matrix(ncol = k, nrow = length(clust.assess))
cluster.sizes <- matrix(ncol = k, nrow = k)
for(i in c(1:k)){
  row.clust[i] <- paste("Cluster-", i, " size")
}
for(i in c(2:k)){
  stats.names[i] <- paste("Test", i-1)
  
  for(j in seq_along(clust.assess)){
    output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
    
  }
  
  for(d in 1:k) {
    cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
    dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
    cluster.sizes[d, i]
    
  }
}
output.stats.df <- data.frame(output.stats)
cluster.sizes <- data.frame(cluster.sizes)
cluster.sizes[is.na(cluster.sizes)] <- 0
rows.all <- c(clust.assess, row.clust)
# rownames(output.stats.df) <- clust.assess
output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
colnames(output) <- stats.names[2:k]
rownames(output) <- rows.all
is.num <- sapply(output, is.numeric)
output[is.num] <- lapply(output[is.num], round, 2)
output
}
```

```{r}
# find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, hc, 15))), 
  aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative (complete) - Elbow") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))+
  theme_dark()
```

```{r}
# find optimal k - Silhouette
num_k <- find_k(hc)
plot(num_k)
```

```{r}
# hierarchical clustering using various methods - average
hc <- hclust(clus_dist, method = "average")

# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, average method")
rect.hclust(hc, k=5, border="gold3")
```

```{r}
# hierarchical clustering using various methods - centroid
hc <- hclust(clus_dist, method = "centroid")

# find k
num_k <- find_k(hc)
plot(num_k)

# Dendogram
plot(hc, label = FALSE, main = "Agglomerative, centroid method")
rect.hclust(hc, k=3, border="blue")
```

### Backup: Hierarchical Clustering - Divisive

```{r}
divisive.clust <- diana(as.matrix(clus_dist), 
                  diss = TRUE, keep.diss = TRUE)
plot(divisive.clust, label=FALSE, main = "Divisive Clustering")

# k is for user to calibrate
rect.hclust(divisive.clust, k=6, border="gold3")
```

```{r}
# Find optimal k - elbow method
ggplot(data = data.frame(t(cstats.table(clus_dist, divisive.clust, 15))), 
  aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Divisive clustering - elbow") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))
```

# Time Series Clsutering (by month)

```{r}
# dtwclust
# tsclust

```

# Introduction: Package and Dataset

```{r}
#load lib
pacman::p_load(scales, viridis, hrbrthemes, lubridate, gridExtra, knitr, data.table, ggthemes, CGPfunctions, ggHoriPlot, gapminder, gganimate, ggbraid, ggstatsplot, ggiraph, plotly, performance, nortest, patchwork, ggdist, ggridges, tidyverse)
```

### Consumption by Dwelling Type (Intro)

```{r}
dwelling <- T3.4 %>%
  filter(year %in% c(2005:2022)) %>%
  filter(month %in% c(1:12)) %>%
  filter(DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
                              '5-room and Executive',
                              'Private Apartments and Condominiums',
                              'Landed Properties', 'Others')) %>%
  mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd")) %>%
  mutate(monthyear = format(as.Date(date), "%b %Y"))

#Add Private vs Public Classification
dwelling$class <- case_when(
    dwelling$DWELLING_TYPE %in% c('Private Apartments and Condominiums',
                                 'Landed Properties', 'Others') ~ "Private",
    dwelling$DWELLING_TYPE %in% c('1-room / 2-room','3-room','4-room',
                                  '5-room and Executive') ~ "Public")
```

##New: Animated Bar Plots

```{r}
dwelling_bar <- dwelling %>% 
  select('date','DWELLING_TYPE','consumption_GWh')

dwelling_bar <- as.Date(dwelling_bar$date, format="%d-%m,-%Y") 
```

```{r}
# Creating the rank and relative value
bar_data <- dwelling_bar %>%
  group_by(date) %>%
  mutate(rank = rank(-consumption_GWh),
         Value_rel = ifelse(length(consumption_GWh) == 0, 0, consumption_GWh/consumption_GWh[rank==1]),
         Value_lbl = paste0(" ", consumption_GWh)) %>%
  ungroup()

```

```{r}
#animated bar plot

anim <- ggplot(bar_data, aes(rank, group = DWELLING_TYPE, 
                fill = as.factor(DWELLING_TYPE), color = as.factor(DWELLING_TYPE))) +
  geom_tile(aes(y = consumption_GWh,
                height = consumption_GWh,
                width = 0.9), alpha = 0.8, color = NA) +
  geom_text(aes(y = consumption_GWh, label = paste(" ",DWELLING_TYPE,"\n",Value_lbl)), hjust = 0, color="black") +
  coord_flip(clip = "off", expand = FALSE) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_reverse() +
  guides(color = FALSE, fill = FALSE) +
  theme(axis.line=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none",
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        panel.grid.major.x = element_line(linewidth=.1, color="grey80" ),
        panel.grid.minor.x = element_line(linewidth=.1, color="grey80" ),
        plot.title=element_text(size=20, hjust=0.5, face="bold", colour="black"),
        plot.subtitle=element_text(size=18, hjust=0.5, face="italic", color="grey"),
        plot.caption =element_text(size=8, hjust=0.5, face="italic", color="grey"),
        plot.background=element_blank(),
       plot.margin = margin(2,2, 2, 2, "cm")) 

animated <- anim +
  transition_states(date, transition_length = 6, state_length = 1) + 
  view_follow(fixed_y = c(0,500)) +
  ease_aes('cubic-in-out') + 
  labs(title = "Electricity Consumption by Dwelling Type in: {closest_state}", 
       x = "Consumption (GWh)",
       caption="Source:ema.gov.sg")

animate(animated, 500, fps = 5,  width = 800, height = 600, 
        renderer = gifski_renderer("gganim.gif"))
```

```{r}
#linechart # backup
ggplot(data = dwelling, aes(x = date)) +
  geom_line(aes(y = consumption_GWh, colour = DWELLING_TYPE)) + 
  labs(title = "Electricity Consumption by Dwelling Type",
      x = "Year", y = "Consumption (GWh)") +
  scale_color_discrete(name="") +
  theme(legend.position="bottom")
```

```{r}
# cycleplot for each dwelling type
select_type <- 'Private Apartments and Condominiums'

select_dwelling <- dwelling %>% 
  filter(DWELLING_TYPE %in% c(select_type)) %>%
  mutate(year = factor(year, levels = 2005:2022),
         month = factor(month, levels = 1:12))

#Computing year average by months
hline.data <- select_dwelling %>%
  group_by(month) %>%
  summarise(avg_cons = mean(consumption_GWh))

#Plotting cycle plot for imports
ggplot() + 
  geom_line(data = select_dwelling,
            aes(x=year,y=consumption_GWh, group=month), colour = "black") +
  geom_hline(data = hline.data,
             aes(yintercept=avg_cons),
             linetype=6, 
             colour="red", 
             linewidth=0.5) +
  facet_grid(~month) +
  theme(axis.text.x = element_text(angle=90, vjust=1, hjust=1)) +
  labs(title = "Cycleplot for household electricity consumption (GWh), Jan 2005-Jun 2022",
       subtitle = paste0('Dwelling Type: ',select_type)) +
  scale_x_discrete(breaks=c("2005","2010","2015","2020")) +
  xlab("") +
  ylab("GWh")
```

Another consideration for peak system demand is lag plot to check for seasonality.

```{r}
#Display rate of change using Slopegraph
#User can choose any 2 years for comparison
startyear <- 2005
endyear <- 2021

cons_yr <- dwelling
cons_year <- cons_yr %>%
  group_by(DWELLING_TYPE, year) %>%
  summarise(mean_cons=round(mean(consumption_GWh),2))

p_slopegraph <- cons_year %>% 
  mutate(year = factor(year)) %>%
  filter(year %in% c(startyear,endyear)) %>%
  newggslopegraph(year, mean_cons, DWELLING_TYPE)

p_slopegraph1 <- p_slopegraph + labs(title = "Monthly Household Electricity Consumption between 2 years",
                subtitle = "",
                caption = "Source:ema.gov.sg")

p_slopegraph1
```

### Introduction: Total Household Electricity Consumption by Town/Region

```{r}
town <- subset(T3.5, Description != 'Overall' & Description !='Central Region' & 
                 Description !='East Region' & Description !='North East Region' &
                 Description !='North Region' & Description !='West Region' &
                 kwh_per_acc != 's' & dwelling_type != 'Private Housing' &
                 dwelling_type != 'Public Housing' & month != 'Annual') %>%
  mutate(kwh_per_acc = as.numeric(kwh_per_acc)) %>%
  mutate(date = parse_date_time(paste0(year, "-", month,"-1"),"ymd"))

#Adding housing type
town$type <- case_when(
    town$dwelling_type %in% c('Private Apartments and Condominiums',
                                 'Landed Properties', 'Others') ~ "Private",
    town$dwelling_type %in% c('1-room / 2-room','3-room','4-room',
                                  '5-room and Executive') ~ "Public")
```

```{r}
#Horizon plot

```

```{r}
#boxplot
inputyr <- 2021

town_boxplot <- town %>% 
  filter(year %in% c(inputyr))

#PLotting the chart
town_boxplot %>%
  mutate(Description = fct_reorder(Description, kwh_per_acc)) %>%
  ggplot( aes(x=Description, y=kwh_per_acc, fill=Description)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
#    geom_jitter(color="black", size=0.4, alpha=0.9) +
#    theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle(paste0("Electricity Consumption by each Town, Year ",inputyr)) +
    xlab("") +
    coord_flip()


```

```{r}
#barchart: number of towns in each region
town_cnt <- town %>% 
  filter(year %in% c(inputyr)) %>%
  group_by(Region) %>%
  summarise(town_count = n_distinct(Description))

#bar plot
town_cnt %>%
  mutate(Region = fct_reorder(Region, town_count)) %>%
  ggplot( aes(x=Region, y=town_count)) +
    geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) +
    coord_flip() +
    xlab("Regions") +
    ylab("Number of towns") +
    labs(title=paste0("Number of Towns in each Region, Year ",inputyr)) +
    theme_bw()
```

# Inferential Analysis

```{r}
#Confidence Intervals of Median Household consumption
private_uncert <- ggplot(data = dwelling |> filter(year == givenyear), 
                      aes(x = DWELLING_TYPE, y = consumption_GWh)) +
  stat_pointinterval(point_interval = "median_qi",
                     .width = c(0.95,0.99),
                     point_color = "red3") +
  labs(title = "Visualising Confidence Intervals of Median Electricity Consumption",
       x = "", y = "GWh", subtitle = paste0("Year ", givenyear)) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

private_uncert
```

```{r}
#Comparison of Median Consumption by Dwelling Type per year
#Give user choice to choose the year
givenyear <- 2021

#plotting violin plot by dwelling type for private and public housing
private <- ggbetweenstats(data = dwelling |> filter(class == "Private", year == givenyear), x = DWELLING_TYPE, y = consumption_GWh,
               xlab = "Dwelling Type", ylab = "GWh",
               type = "np", pairwise.comparisons = T, pairwise.display = "ns", 
               mean.ci = T, p.adjust.method = "fdr",  conf.level = 0.95,
               title = "Private",
               package = "ggthemes", palette = "Tableau_10") +
  theme(axis.title.x = element_blank())
#  + scale_y_continuous(limits = c(0, 1500000))

public <- ggbetweenstats(data = dwelling |> filter(class == "Public", year == givenyear), x = DWELLING_TYPE, y = consumption_GWh,
               xlab = "Dwelling Type", ylab = "GWh",
               type = "np", pairwise.comparisons = T, pairwise.display = "ns", 
               mean.ci = T, p.adjust.method = "fdr",  conf.level = 0.95,
               title = "Public",
               package = "ggthemes", palette = "Tableau_10") +
  theme(axis.title.x = element_blank())
#  + scale_y_continuous(limits = c(0, 1500000))

#combining plots
combine_plots(
  list(private, public),
  plotgrid.args = list(nrow = 5),
  annotation.args = list(
    title = "Comparison of Monthly Household Electricity Consumption by Dwelling Type",
    subtitle = paste0("Year",givenyear),
    theme = theme(
      plot.subtitle = element_text(size = 10),
      plot.title = element_text(size = 12))))
```

```{r}
#Allow users to choose apply.quarterly or apply.yearly

# Custom function to return mean, sd, quantiles
custom_stat <- function(x, na.rm = TRUE, ...) {
    # x     = numeric vector
    # na.rm = boolean, whether or not to remove NA's
    # ...   = additional args passed to quantile
    c(mean    = mean(x, na.rm = na.rm),
      stdev   = sd(x, na.rm = na.rm),
      quantile(x, na.rm = na.rm, ...)) 
}

# Applying the custom function by quarter
probs = c(0.25, 0.5, 0.75)

stats_sysdemand <- sysdemand %>%
  tq_transmute(
    select     = peak_system_demand_mw,
    mutate_fun = apply.quarterly, 
    FUN        = custom_stat,
    na.rm      = TRUE,
    probs = probs
    )

#Plotting 1st & 3rd quartile vs median
stats_sysdemand %>%
    ggplot(aes(x = date, y = `50%`)) +
    # Ribbon
    geom_ribbon(aes(ymin = `25%`, ymax = `75%`), 
                color = palette_light()[[1]], fill = palette_light()[[1]], alpha = 0.5) +
    # Points
    geom_point() +
    geom_smooth(method = "loess", se = FALSE) + 
    # Aesthetics
    labs(title = "Average Monthly Peak System Demand by Quarter, Jan'05 to Jun'22",
         x = "", y = "MW",
         subtitle = "Range of 1st and 3rd quartile to show volatility") +
    scale_color_tq(theme = "dark") +
    theme_tq()
```

```{r}
#Plotting mean vs std dev
stats_sysdemand %>%
    ggplot(aes(x = stdev, y = mean)) +
    geom_point() +
    geom_smooth(method = "lm") + 
    labs(title = "Average Monthly Peak System Demand by Quarter, Jan'05 to Jun'22",
    subtitle = "Mean vs Standard Deviation") +
    scale_color_tq() +
    theme_tq()
```

```{r}
library(forecast)
library(tsibble)
library(zoo)

  arima <- town
  arima$ym <- yearmonth(as.yearmon(paste(arima$year, arima$month), "%Y %m"))
  a <- arima %>%
    group_by(ym) %>%
    summarise(avgcon = mean(kwh_per_acc, na.rm = TRUE)) %>%
    ungroup()
  
  arima_ts <- ts(data=a$avgcon, start = c(2005,1), end = c(2022,6), frequency=12)
  n <- auto.arima(arima_ts)
  n
  plot(n)
  forecast(arima_ts, fit = arima(window(arima_ts)))
  
# arima_ts <- ts(data=a$avgcon, start = c(2005,1), end = c(2022,6), frequency=12)

# fit <- ets(window(arima_ts))
# fit2 <- arima(window(arima_ts))
# fit3 <- tslm(window(arima_ts))
# Generate forecasts using the ARIMA method
# plot(forecast(arima_ts, h =10))
# plot(forecast(arima_ts, h =10, model = fit2))


```

```{r}
library(fracdiff)

m <- modelAR(arima_ts, FUN)
fit <- arfima(arima_ts)
tsdisplay(residuals(fit))
plot(forecast(m))
```

```{r}
arima <- T2.3
  arima$Date <- yearmonth(as.yearmon(paste(arima$year, arima$mth), "%Y %m"))
  arima_ts <- ts(data=arima$peak_system_demand_mw)
  arima_arima = auto.arima(arima_ts, d =2, D =1, seasonal = FALSE, trace=TRUE)
```

# Wei Lun

Final (Intro) Interactive Sparklines for a year

```{r}
remotes::install_github("timelyportfolio/dataui")
library(dataui)
```

```{r}
pacman::p_load(reactable, reactablefmtr, gt, gtExtras)
```

# Final (Intro): Interactive Sparklines for a time period (Bandline/Mean)

```{r}
#data formatting
d_sparks <- dwelling %>%
  filter(year %in% c(startyear:endyear)) %>%
  mutate(`Dwelling Type` = DWELLING_TYPE) %>%
  group_by(`Dwelling Type`) %>%
  summarize(`Monthly Consumption` = list(consumption_GWh))
#react_sparkline
reactable(
  d_sparks,
  defaultPageSize = 13,
  columns = list(
    `Dwelling Type` = colDef(maxWidth = 200),
    `Monthly Consumption` = colDef(
      cell = react_sparkline(
        d_sparks,
        highlight_points = highlight_points(
          min = "red", max = "blue"),
        line_width = 1,
        bandline = "innerquartiles",
        bandline_color = "green"
        )
    )
  )
)
```

# Final (Intro): Interactive Sparklines for a time period (Mean)

```{r}
#Allow users to switch between bandline and mean statline
reactable(
  d_sparks,
  defaultPageSize = 13,
  columns = list(
    `Dwelling Type` = colDef(maxWidth = 200),
    `Monthly Consumption` = colDef(
      cell = react_sparkline(
        d_sparks,
        highlight_points = highlight_points(
          min = "red", max = "blue"),
        statline = "mean"
        )
    )
  )
)       
```

Final Report & Bullet

```{r}
#Preparing the data for report
dwelling %>%
  filter(year %in% c(startyear:endyear)) %>%
  group_by(DWELLING_TYPE) %>%
  summarise("Min" = min(consumption_GWh, na.rm = T),
            "Max" = max(consumption_GWh, na.rm = T),
            "Average" = mean(consumption_GWh, na.rm = T)
            ) %>%
  gt() %>%
  fmt_number(columns = 4,
    decimals = 2)
```
